[ This is -*-Indented-Text-*- ]

TODO list for librep
********************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -


Outstanding bugs
================

 ! case uses eq comparison, should use eql or equal?

 ! scheme define/lambda doesn't splice begin forms

 ! fluid-let custom compiler is disabled

 ! can't do numerator/denominator of flonums

 ! ref cache can thrash when switching structures quickly

   also, the first level lookup of foo#bar isn't cached

 ! interfaces aren't re-parsed when modules are reloaded

 ! environment of macro expanders is not consistent

   interpreted code closes macros in the usual lexical environment,
   the compiler closes them in the *root-strcucture* since the
   lexical environment of the compiled file doesn't exist

   Xerox scheme closes all macros in the `initial environment', this
   would provide consistency, but would break existing code

   also, macro memoization is very brittle

 ! no way to export variables from C code

 ! doesn't handle NaN or Inf in floats properly (at all)

 ! ((call/cc call/cc) (call/cc call/cc)) can't be interrupted, and it
   eats all memory

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! It's relatively easy to blow the stack when regexp matching. Try
   searching for `/\*(.|\n)*\*/' in a C file with reasonable large
   comments.

 ! If a compiled file FOO.jlc is made from source file FOO, but FOO is
   newer, load doesn't notice, and loads the invalid FOO.jlc

 ! it's impossible for scripts to present their own --help option

 ! non-fixnum numbers can't be dumped / dump totally broken re: modules

 ! `random' only accepts its range as a fixnum

 ! unwind-protect may not evaluate it's cleanup forms, consider:

   (call/cc (lambda (exit)
	      (unwind-protect
		  (exit)
		(message "Foo!"))))
   
   Just call this a [mis-] feature for now..

 ! it's legal to do (set foo 42) where the contents of foo has a
   lexical binding

   this breaks: (let ((var 'loop))
		  (let loop ((foo t))
		    (set var print)
		    (loop foo)))


General programming tasks:
==========================

 - the gc sucks

   raising garbage-threshold to 200k helps, but gc still takes about
   25% of cpu time for the gtk-glue.c build time

   the current gc has a tradeoff between mark time and sweep time,
   raising the threshold decreases cumulative mark time, but increases
   sweep time. Increasing the threshold to 400k still reduces the
   overall time, but only by about 4% over the 200k value

   is it possible to add a good (generational?) gc?

 - remove special forms (replacing them with macros) where both
   possible and desirable

   The current (29-3-99) list of special forms is:

   case catch cond condition-case defvar lambda prog1 progn quote setq
   unwind-protect while with-object

 - eliminate tail calls in interpreted code

   also, subrs can't be called tail recursively (e.g. call/cc apply ..?)

 - add a hygienic macro facility

 - do JIT compilation of bytecode where profitable

   there's now GNU lightning, a VCODE-like system, using C macros to do
   portable runtime code generation

   Only do this for _heavily_ used bytecode subrs. Measure this by
   adding an extra vector slot, and counting the number of vm
   iterations

 - Optimize compilation of case statements

   1. handle constant keys

   2. optimize the search

 - Eliminate lexically-bound symbols from compiled code?

   currently the symbols are only used when the binding is created; all
   access is done through lexical addressing.

   lexical leaf procedures (i.e. those without any `enclose' or
   `make-closure' instructions) don't need to include symbols, since
   there's no way they could be needed

 - Sandboxed bytecode interpreter

   the default vm assumes that the compiler makes no errors (i.e. it
   ignores some range/type checks)

   a `safe' vm would check for things like:

     * stack overflow
     * range of indices to the vector of constants
     * validity of refg/setg instructions
     * invalid lexical addresses to refn/setn
     * etc..

   implement this as a plugin?

 - Implement weak-pairs or equivalent

   could use normal cons types for this, but allocate from a `weak'
   freelist, then only gc has to differentiate between weak and
   non-weak pairs

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Add more backends for accessing remote files

   Make remote-rcp work properly, and add others (ssh, http, ..?)

 - Make the compiler optimise its output

   now the lisp is mostly lexically scoped, there should be much
   more potential for aggressive optimisation


Manual tasks:
=============

 + Document the error-mode and interrupt-mode variables

 + Document the internals (i.e. the C interface)
