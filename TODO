[ This is -*-Indented-Text-*- ]

TODO list for librep
********************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -


Outstanding bugs
================

 ! requiring a dl module with a req_requires line opens those as well

 ! (read-from-string "((a)") doesn't terminate?

 ! scheme define/lambda doesn't splice begin forms

 ! the scheme module fails some of the guile test.scm cases

 ! can't do numerator/denominator of flonums

 ! ref cache can thrash when switching structures quickly

   also, the first level lookup of foo#bar isn't cached

 ! interfaces aren't re-parsed when modules are reloaded

 ! environment of macro expanders is not consistent

   interpreted code closes macros in the usual lexical environment,
   the compiler closes them in the *root-strcucture* since the
   lexical environment of the compiled file doesn't exist

   Xerox scheme closes all macros in the `initial environment', this
   would provide consistency, but would break existing code

 ! macro memoization loses

   e.g. if same (eq) expression is expanded in different structures

   OTOH, there is little or no chance of this ever happening

 ! no way to export variables from C code

 ! doesn't handle NaN or Inf in floats properly (at all)

 ! ((call/cc call/cc) (call/cc call/cc)) can't be interrupted, and it
   eats all memory

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! It's relatively easy to blow the stack when regexp matching. Try
   searching for `/\*(.|\n)*\*/' in a C file with reasonable large
   comments.

 ! If a compiled file FOO.jlc is made from source file FOO, but FOO is
   newer, load doesn't notice, and loads the invalid FOO.jlc

 ! it's impossible for scripts to present their own --help option

 ! non-fixnum numbers can't be dumped / dump totally broken re: modules

 ! `random' only accepts its range as a fixnum

 ! unwind-protect may not evaluate it's cleanup forms, consider:

   (call/cc (lambda (exit)
	      (unwind-protect
		  (exit)
		(message "Foo!"))))
   
   Just call this a [mis-] feature for now..

 ! it's legal to do (set foo 42) where the contents of foo has a
   lexical binding

   this breaks: (let ((var 'loop))
		  (let loop ((foo t))
		    (set var print)
		    (loop foo)))

 + document in manual: current-utime, new read syntaxes

 + make rep_call_lispn () public?


General programming tasks:
==========================

 + do something with the define-value ugliness?

 - move the gtk-independent parts of the rep-gtk glue generator and
   support code to librep

 - decide whether to have hierarchical modules

   (recent acm toplas paper by Matthias Blume about this in ML)

 - add defadvice (port from elisp? other implementations?)

 - Compiler could annotate output files with their dependences

 - I/O shouldn't block all threads

   wait_for_input () already groks threads, so I think the only problem
   is the use of stdio/fd functions. How does stdio handle streams that
   have been set non-blocking? Maybe reimplement basic stdio?

   (there is now support for waking threads via polling)

 - add regression tests

 - scheme compilation is worse than rep compilation

   should be able to make this a lot better, maybe not as good as rep
   code (since the vm primitives are designed for that), but still a
   lot better..

   [ it's better now, but still room for improvement ]

 - the gc sucks

   is it possible to add a good (generational?) gc?

   could sweeping be sped up by prefetching cache lines?

   do lazy sweeping of block-allocated objects? (problem with cons mark bit?)

   do mostly non-recursive marking? (mark stack)

   [ tried this -- marginally slower than current method ]

 - remove special forms (replacing them with macros) where both
   possible and desirable

   The current (29-3-99) list of special forms is:

   case catch cond condition-case defvar lambda progn quote setq unwind-protect

 - subrs can't be called tail recursively (e.g. call/cc apply ..?)

 - add a hygienic macro facility

   this may be overkill? capture of introduced bindings can be avoided
   using gensyms, capture of introduced free variables could be avoided
   by introducing a way of tagging variable references with the
   structure they need to be dereferenced in.

   [ I have an experimental low-level hygienic macro implementation,
     but it's a long way from being useful ]

 - do JIT compilation of bytecode where profitable

   there's now GNU lightning, a VCODE-like system, using C macros to do
   portable runtime code generation

   Only do this for _heavily_ used bytecode subrs. Measure this by
   adding an extra vector slot, and counting the number of vm
   iterations

   Another option is to generate direct-threaded code from the bytecode
   (and cache it). I have an attempt at this but it needs either (1) an
   extra pass to detect labels, or (2) to maintain a strict mapping
   between bytecode addresses and direct-code addresses

   There's an interesting paper about automatically generating meta
   instructions to suit individual instruction sequences, PLDI 98 or
   something (check citeseer for it). Applied with reasonable success
   to Caml interpreter

 - Optimize compilation of case statements

   1. handle constant keys

   2. optimize the search

 - Sandboxed bytecode interpreter

   the default vm assumes that the compiler makes no errors (i.e. it
   ignores some range/type checks)

   a `safe' vm would check for things like:

     * stack overflow
     * range of indices to the vector of constants
     * validity of refg/setg instructions
     * invalid lexical addresses to refn/setn
     * etc..

   implement this as a plugin?

   OCaml uses cryptographic signatures to ensure that bytecode was
   created by a trusted source

 - Implement weak-pairs or equivalent

   could use normal cons types for this, but allocate from a `weak'
   freelist, then only gc has to differentiate between weak and
   non-weak pairs

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Add more backends for accessing remote files

   Make remote-rcp work properly, and add others (ssh, http, ..?)

 - Make the compiler optimise its output

   now the lisp is mostly lexically scoped, there should be much
   more potential for aggressive optimisation


Manual tasks:
=============

 + Document the error-mode and interrupt-mode variables

 + Document the internals (i.e. the C interface)
