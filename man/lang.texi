@c The Programmer's Manual -*-Texinfo-*-

@chapter The language
@cindex The language
@cindex Lisp, the rep dialect
@cindex rep, the Lisp dialect

This chapter of the manual is a full guide to the librep Lisp
programming language, including documentation for most of the built-in
functions.

XXX Much of this manual is out of date. Take all information with a
medium-sized pinch of salt...

@menu
* Intro::                       Introduction and Lisp conventions

* Data Types::                  Data types and values in Lisp
* Numbers::                     Integers and arithmetic functions
* Sequences::                   Ordered sequences of data values
* Symbols::                     Symbols are uniquely named objects

* Evaluation::                  Evaluating expressions
* Control Structures::          Special forms. Conditionals, loops, etc@dots{}
* Variables::                   Symbols represent named variables
* Functions::                   Functions are the building blocks of Lisp
                                  programs
* Macros::                      User-defined control structures

* Streams::                     Data sinks and sources; character streams
* Loading::                     Programs are stored in files
* Compiled Lisp::               Making programs run faster

* Hooks::                       Hooks allow the extending of Jade

* Files::                       Manipulating files in the filing system
* Processes::                   Jade can launch and control subprocesses
                                  when running under Unix

* Miscellaneous Functions::     Functions which don't fit elsewhere in
                                  this manual

* Debugging::                   How to debug Lisp programs
* Tips::                        General recommendations for Lisp programmers
@end menu

@node Intro, Data Types, , The language
@section Introduction
@cindex Introduction, Lisp

As you have probably gathered by now, Jade is largely controlled by its
built in programming language: a dialect of Lisp containing many
extensions (non-standard data types and functions) to make it suitable
for controlling an editor. Through this language Jade can be customised and
extended.

I have attempted to make the ``standard'' portion of the language (i.e.
anything a normal Lisp would have; not related to editing) as compatible
with GNU Emacs Lisp as possible. In some areas this rule doesn't apply,
there will usually be a good reason for this. A few functions have been
inspired by Common Lisp.

The areas of the language which control the @emph{editor} are @emph{not}
compatible with Emacs; some functions may be similar but since the two
editors are fundamentally different I have not attempted to conform with
the Emacs API.

All programs written using only the information in this manual should
be compatible with future revisions of Jade.

This following sections explain some of the most important Lisp concepts
and the conventions I've used in this manual.

@menu
* nil and t::                   Boolean values in Lisp
* The Lisp Reader::             Basic program structure
* Notation::                    Special glyphs used
* Descriptions::                How functions and variables are documented
@end menu

@node nil and t, The Lisp Reader, , Intro
@subsection nil and t
@cindex nil and t
@cindex t
@cindex Boolean values

The two boolean values in Lisp are the symbols @code{nil} (FALSE) and
@code{t} (TRUE). Both these symbols always evaluate to themselves (so they
do not have to be quoted), any attempt to change their values is an error.

All of the conditional instructions regard @emph{anything} which is not
@code{nil} as being TRUE (i.e. not-FALSE). The actual symbol @code{t}
should be used where a TRUE boolean value must be explicitly stated to
increase the clarity of the code.

This is not the end of the story; @code{nil} actually has another meaning:
it represents the empty list. This is a consequence of how lists are
constructed in Lisp, a list of zero elements is stored as the symbol
@code{nil}.

To the Lisp system itself there is absolutely no difference between @code{()}
(the notation for a list with zero elements) and @code{nil} (the symbol nil).
When writing code however, the list notation is usually used when the
programmer regards the value as a list and the @code{nil} notation when
its value as a boolean is to be emphasised.

@node The Lisp Reader, Notation, nil and t, Intro
@subsection The Lisp Reader
@cindex The Lisp reader
@cindex Reader, the Lisp

Lisp programs and functions are stored internally as normal Lisp data
objects, the Lisp Reader is the process used to translate textual
descriptions of Lisp objects into the data structures used to represent
the objects.

The Lisp Reader is the collection of internal functions accessed by the
@code{read} Lisp function. It reads a character at a time from an input
stream until it has parsed a whole Lisp object.

@xref{Data Types}.

@node Notation, Descriptions, The Lisp Reader, Intro
@subsection Notation
@cindex Notation
@cindex Manual notation

Wherever an example of evaluating a Lisp form is shown it will be
formatted like this,

@lisp
(+ 1 2)
    @result{} 3
@end lisp

@noindent
The glyph @samp{@result{}} is used to show the computed value of a form.

When two forms are shown as being exactly equivalent to one another the
glyph @samp{@equiv{}} is used, for example,

@lisp
(car some-variable) @equiv{} (nth 0 some-variable)
@end lisp

Evaluating some forms result in an error being signalled, this is denoted
by the @samp{@error{}} glyph.

@lisp
(read-file "/tmp/foo")
    @error{} File error: No such file or directory, /tmp/foo
@end lisp

@node Descriptions, , Notation, Intro
@subsection Descriptions
@cindex Descriptions
@cindex Functions, descriptions of
@cindex Variables, descriptions of

The simplest type of descriptions are the descriptions of variables
(@pxref{Variables}), they look something like,

@defvar grains-of-sand
This imaginary variable contains the number of grains of sand in a
one-mile long stretch of an averagely sandy beach.
@end defvar

Hooks (@pxref{Hooks}) are also described in this format, the only
difference is that @samp{Variable:} is replaced by @samp{Hook:}.

Functions (@pxref{Functions}) and macros (@pxref{Macros}) have more complex
descriptions; as well as the name of the thing being described, they also
have a list of arguments which the thing will accept. Each argument in
the list is named and may be referred to in the body of the description.

Two `special' arguments may be used, @samp{&optional} and @code{&rest}.
They have the same meaning as when used in the lambda-list of a function
definition (@pxref{Lambda Expressions}), that is @samp{&optional} means
that all further arguments are optional, and @samp{&rest} means that
zero or more argument values are coalesced into a list to be used
as the value of the following argument.

An example function definition follows.

@defun useless-function first &optional second &rest tail
This function returns a list consisting of the values @var{second} (when
undefined the number 42 is used), all the items in the list @var{tail}
and @var{first}.

@lisp
(useless-function 'foo 'bar 'xyz 20)
    @result{} (bar xyz 20 foo)

(useless-function '50)
    @result{} (42 50)
@end lisp
@end defun

Macros and commands (@pxref{Commands}) are defined in the same way with
@samp{Macro:} or @samp{Command:} replacing @samp{Function:}.

Special forms (@pxref{Special Forms}) are described similarly to functions
except that the argument list is formatted differently since special forms
are, by definition, more flexible in how they treat their arguments. Optional
values are enclosed in square brackets (@samp{[@var{optional-arg}]}) and
three dots (@samp{@var{repeated-arg}@dots{}}) indicate where zero or
more arguments are allowed.

@node Data Types, Numbers, Intro, The language
@section Data Types
@cindex Data types

The way that data values are represented in Lisp is fundamentally different
to more ``conventional'' languages such as C or Pascal: in Lisp each piece
of data (a @dfn{Lisp Object}) has two basic attributes, the actual data
and a tag value defining the @emph{type} of the object. This means that type
checking is performed on the actual data itself, not on the ``variable''
holding the data.

All Lisp objects are a member of one of the primitive types; these are
types built into the Lisp system and can represent things like strings,
integers, cons cells, vectors, etc@dots{}

More complex types of object can be constructed from these primitive types,
for example a vector of three elements could be regarded as a type
@code{triple} if necessary. In general, each separate type provides a
predicate function which returns @code{t} when applied to an object of its
type.

@menu
* Types Summary::               List of the most common types
* Read Syntax::                 Some types can be constructed from source code
* Printed Representation::      All types can be printed
* Equality Predicates::         How to test two objects for equality
* Comparison Predicates::       Comparing two objects as scalars
* Type Predicates::             Each type has a predicate defining it
* Garbage Collection::          Reusing memory from stale objects
@end menu

@node Types Summary, Read Syntax, , Data Types
@subsection Types Summary
@cindex Types summary
@cindex Data types, summary of

Each separate data type is documented in its own section, this is a just a
table of the more common types.

@table @dfn
@item Integer
32-bit signed integers. @xref{Numbers}.

@item Cons cell
An object containing two other Lisp objects. @xref{Cons Cells}.

@item List
A sequence of objects, in Lisp lists are not primitive types, instead they
are made by chaining together Cons cells. @xref{Lists}.

@item Vector
A one-dimensional array of objects. @xref{Vectors}.

@item String
A vector of characters. @xref{Strings}.

@item Array
An ordered sequence of objects which can be accessed in constant time,
either a vector or a string. @xref{Sequences}.

@item Sequence
An ordered sequence of objects, either a list or an array.
@xref{Sequences}.

@item Symbol
A symbol is a named object; they are used to provide named variables and
functions. @xref{Symbols}.

@item File
A link to a file in the operating system's filing system, allows access
to the file as a stream. @xref{Files}.

@item Stream
Serial data sinks and sources. @xref{Streams}.

@item Void
No type, only used in symbols to represent an unset function or variable
value.

@item Process
An object through which processes may be created and controlled.
@xref{Processes}.
@end table

@node Read Syntax, Printed Representation, Types Summary, Data Types
@subsection Read Syntax
@cindex Read syntax
@cindex Syntax of objects

As previously noted the Lisp reader translates textual descriptions of
Lisp objects into the object they describe (source files are simply
descriptions of objects). However, not all data types can be created
in this way: in fact the only types which can are integers, strings,
symbols, cons cells (or lists) and vectors, all others have to be
created by calling functions.

@cindex Comments
Note that comments in a Lisp program are introduced by the semi-colon
character (@samp{;}). Whenever the Lisp reader encounters a semi-colon
where it's looking for the read syntax of a new Lisp object it will
discard the rest of the line of input. @xref{Comment Styles}.

The @dfn{read syntax} of an object is the string which when given to the
reader as input will produce the object. The read syntax of each type
of object is documented in that type's main section of this manual but
here is a small taste of how to write each type.

@table @asis
@item Integers
An integer is simply the number written in either decimal, octal (when the
number is preceded by @samp{0}) or hexadecimal (when the number is preceded
by @samp{0x}). An optional minus sign may be the first character in a
number. Some examples are,

@lisp
42
    @result{} 42

0177
    @result{} 127

0xff
    @result{} 255

-0x10
    @result{} -16
@end lisp

@item Strings
The read syntax of a string is simply the string with a double-quote
character (@samp{"}) at each end, for more details see @ref{Strings}.

@lisp
"This is a string"
@end lisp

@item Cons cells
A cons cell is written in what is known as @dfn{dotted pair notation} and is
just the two objects in the cell separated by a dot and the whole thing in
parentheses,

@lisp
(@var{car} . @var{cdr})
@end lisp

@item Lists
The syntax of a list is similar to a cons cell (since this is what lists
are made of): no dot is used and there may be zero or more objects,

@lisp
(@var{object1} @var{object2} @var{object3} @dots{})

("foo" ("bar" "baz") 100)
@end lisp

@noindent
The second example is a list of three elements, a string, another list and
a number.

@item Vectors
The read syntax of a vector is very similar to that of a list, simply
use square brackets instead of parentheses,

@lisp
[@var{object1} @var{object2} @var{object3} @dots{}]
@end lisp

@item Symbols
A symbol's read syntax is simply its name, for example the read syntax of
a symbol called @samp{my-symbol} is,

@lisp
my-symbol
@end lisp
@end table

@node Printed Representation, Equality Predicates, Read Syntax, Data Types
@subsection Printed Representation
@cindex Printed representation

The @dfn{printed representation} of an object is the string produced
when the object is printed (with one of the @code{print} functions), this
will usually be very similar to the read syntax of the object
(@pxref{Read Syntax}).

Objects which do not have a read syntax @emph{do} have a printed
representation, it will normally be of the form,

@lisp
#<relevant text>
@end lisp

@noindent
where the ``relevant text'' is object-dependent and usually describes
the object and its contents. The reader will signal an error if it
encounters a description of an object in the format @samp{#<@dots{}>}.

@node Equality Predicates, Comparison Predicates, Printed Representation, Data Types
@subsection Equality Predicates
@cindex Equality predicates
@cindex Predicates, equality

@defun eq arg1 arg2
Returns @code{t} when @var{arg1} and @var{arg2} are the same object. Two
objects are the same object when they occupy the same place in memory and
hence modifying one object would alter the other. The following Lisp
fragments may illustrate this,

@lisp
(eq "foo" "foo")	;the objects are distinct
    @result{} nil

(eq t t)		;the same object -- the symbol @code{t}
    @result{} t
@end lisp

Note that the result of @code{eq} is undefined when called on two integer
objects with the same value, see @code{eql}.
@end defun

@defun equal arg1 arg2
The function @code{equal} compares the structure of the two objects @var{arg1}
and @var{arg2}. If they are considered to be equivalent then @code{t} is
returned, otherwise @code{nil} is returned.

@lisp
(equal "foo" "foo")
    @result{} t

(equal 42 42)
    @result{} t

(equal 42 0)
    @result{} nil

(equal '(x . y) '(x . y))
    @result{} t
@end lisp
@end defun

@defun eql arg1 arg2
This function is a cross between @code{eq} and @code{equal}: if @var{arg1}
and @var{arg2} are both numbers then the value of these numbers are compared.
Otherwise it behaves in exactly the same manner as @code{eq} does.

@lisp
(eql 3 3)
    @result{} t

(eql 1 2)
    @result{} nil

(eql "foo" "foo")
    @result{} nil

(eql 'x 'x)
    @result{} t
@end lisp
@end defun

@node Comparison Predicates, Type Predicates, Equality Predicates, Data Types
@subsection Comparison Predicates
@cindex Comparison predicates
@cindex Predicates, comparison

These functions compare their two arguments in a scalar fashion, the arguments
may be of any type but the results are only meaningful for numbers, strings
(ASCII values of each byte compared until a non-matching pair is found then
those two values are compared as numbers) and positions.

@defun > arg1 arg2
Returns @code{t} when @var{arg1} is `greater than' @var{arg2}.
@end defun

@defun >= arg1 arg2
Returns @code{t} when @var{arg1} is `greater than or equal to' @var{arg2}.
@end defun

@defun < arg1 arg2
Returns @code{t} when @var{arg1} is `less than' @var{arg2}.
@end defun

@defun <= arg1 arg2
Returns @code{t} when @var{arg1} is `less than or equal to' @var{arg2}.
@end defun

@node Type Predicates, Garbage Collection, Comparison Predicates, Data Types
@subsection Type Predicates
@cindex Type predicates
@cindex Predicates, type

Each type has a corresponding predicate which defines the objects which
are members of that type.

@itemize @bullet
@item
@code{integerp}

@item
@code{numberp}

@item
@code{null}

@item
@code{consp}

@item
@code{listp}

@item
@code{vectorp}

@item
@code{subrp}

@item
@code{functionp}

@item
@code{sequencep}

@item
@code{stringp}

@item
@code{symbolp}

@item
@code{processp}

@item
@code{filep}
@end itemize

The documentation for these functions is with the documentation for the
relevant type.

@node Garbage Collection, , Type Predicates, Data Types
@subsection Garbage Collection
@cindex Garbage collection

In Lisp, data objects are used very freely; a side effect of this is
that it is not possible to (easily) know when an object is @dfn{stale},
that is, no references to it exist and it can therefore be reused.

The @dfn{garbage collector} is used to overcome this problem; whenever
enough new data objects have been allocated to make it worthwhile,
everything stops and the garbage collector works its way through
memory deciding which objects are still in use and which are stale.
The stale objects are then recorded as being available for reuse and
evaluation continues again.

@defun garbage-collect
Runs the garbage collector, usually this function doesn't need to
be called manually.
@end defun

@defvar garbage-threshold
The number of bytes of data which must be allocated before evaluation
will pause and the garbage collector called.

Its default value is about 100K.
@end defvar

@xref{Idle Actions}.

@node Numbers, Sequences, Data Types, The language
@section Numbers
@cindex Numbers
@cindex Integers

Currently Jade is only capable of representing integers, for this it uses
signed 32-bit integers: this gives a range of -2147483648 through 0 to
2147483647.

The read syntax of an integer is simply the number written in decimal,
octal or hexadecimal. If the integer starts with the string @samp{0x} it
is assumed to be hexadecimal or if it starts with a zero it is treated
as octal. The first character may be an optional minus or plus sign (this
should come before any base-specifier). Examples of valid integer read
syntaxes for the number 42 could be @samp{42}, @samp{0x2a}, @samp{052},
@samp{+052}, @dots{}

An integer's printed representation is simply the number printed in
decimal with a preceding minus sign if it is negative.

@defun numberp object
This function returns @code{t} if @var{object} is a number.
@end defun

@defun integerp object
This function returns @code{t} when @var{object} is an integer.
@end defun

@menu
* Arithmetic Functions::        Adding and substracting@dots{}
* Bitwise Functions::           Using integers as bit-sequences
* Numeric Predicates::          Comparing numbers
* Characters::                  Integers are used to represent characters
@end menu

@node Arithmetic Functions, Bitwise Functions, , Numbers
@section Arithmetic Functions
@cindex Arithmetic Functions
@cindex Numbers, arithmetic functions

There are a number of functions which perform arithmetic operations on
numbers, they take a varying number of integer objects as their arguments
then return a new integer object as their result.

Note that none of these functions check for overflow.

@defun + number1 &rest numbers
This functions adds its arguments then returns their sum. 
@end defun

@defun - number1 &rest numbers
If this function is just given one argument (@var{number1}) that number is
negated and returned. Otherwise each of @var{numbers} is subtracted from
a running total starting with the value of @var{number1}.

@lisp
(- 20)
    @result{} -20

(- 20 10 5)
    @result{} 5
@end lisp
@end defun

@defun * number1 &rest numbers
This function multiplies its arguments then returns the result.
@end defun

@defun / number1 &rest numbers
This function performs division, a running-total (initialised from
@var{number1} is successively divided by each of @var{numbers} then
the result is returned.

@lisp
(/ 100 2)
    @result{} 50

(/ 200 2 5)
    @result{} 20
@end lisp
@end defun

@defun % dividend divisor
Returns the remainder from dividing @var{dividend} by @var{divisor}.

@lisp
(mod 5 3)
    @result{} 2
@end lisp
@end defun

@defun 1+ number
This function returns the result of adding one to @var{number}.

@lisp
(1+ 42)
    @result{} 43
@end lisp
@end defun

@defun 1- number
Returns @var{number} minus one.
@end defun

@node Bitwise Functions, Numeric Predicates, Arithmetic Functions, Numbers
@section Bitwise Functions
@cindex Bitwise functions
@cindex Numbers, bitwise functions

These functions operate on the bit string which an integer is made of.

@defun lsh number count
This function bit-shifts the integer @var{number} @var{count} bits to the
left, if @var{count} is negative @var{number} is shifted to the right
instead.

@lisp
(lsh 1 8)
    @result{} 256

(lsh 256 -8)
    @result{} 1
@end lisp
@end defun

@defun ash number count
Similar to @code{lsh} except that an arithmetical shift is done, this means
that the sign of @var{number} is always preserved.

@lisp
(ash 1 8)
    @result{} 256

(ash -1 2)
    @result{} -4
@end lisp
@end defun

@defun logand number1 &rest numbers
This function uses a bit-wise logical `and' operation to combine all its
arguments (there must be at least one argument).

@lisp
(logand 15 8)
    @result{} 8

(logand 15 7 20)
    @result{} 4
@end lisp
@end defun

@defun logior number1 &rest numbers
Uses a bit-wise logical `inclusive-or' to combine all its arguments (there
must always be at least one argument).

@lisp
(logior 1 2 4)
    @result{} 7
@end lisp
@end defun

@defun logxor number1 &rest numbers
Uses a bitwise logical `exclusive-or' to combine all its arguments
(there must be at least one).

@lisp
(logxor 7 3)
    @result{} 4
@end lisp
@end defun

@defun lognot number
This function inverts all the bits in @var{number}.

@lisp
(lognot 0)
    @result{} -1

(lognot 2)
    @result{} -3

(lognot -1)
    @result{} 0
@end lisp
@end defun

@node Numeric Predicates, Characters, Bitwise Functions, Numbers
@section Numeric Predicates
@cindex Numeric predicates
@cindex Numbers, predicates on
@cindex Predicates on numbers

For the documentation of the functions @code{>}, @code{<}, @code{>=} and
@code{<=} see @ref{Comparison Predicates}.

@defun = number1 number2
This function returns @code{t} if the two integers @var{number1} and
@var{number2} have the same value.

@lisp
(= 1 1)
    @result{} t

(= 1 0)
    @result{} nil
@end lisp
@end defun

@defun /= number1 number2
This function will return @code{t} if @var{number1} and @var{number2}
and not equal to each other.

@lisp
(/= 1 1)
    @result{} nil

(/= 1 0)
    @result{} t
@end lisp
@end defun

@defun zerop number
Returns @code{t} if @var{number} is equal to zero.
@end defun

@node Characters, , Numeric Predicates, Numbers
@subsection Characters
@cindex Characters

In Jade characters are stored in integers. Their read syntax is a question
mark followed by the character itself which may be an escape sequence
introduced by a backslash. For details of the available escape sequences
see @ref{Strings}.

@lisp
?a
    @result{} 97

?\n
    @result{} 10

?\177
    @result{} 127
@end lisp

@defun alpha-char-p character
This function returns @code{t} when @var{character} is one of the
alphabetic characters.

@lisp
(alpha-char-p ?a)
    @result{} t
@end lisp
@end defun

@defun upper-case-p character
When @var{character} is one of the upper-case characters this function
returns @code{t}.
@end defun

@defun lower-case-p character
Returns @code{t} when @var{character} is lower-case.
@end defun

@defun digit-char-p character
This function returns @code{t} when @var{character} is one of the decimal
digit characters.
@end defun

@defun alphanumericp character
This function returns @code{t} when @var{character} is either an alphabetic
character or a decimal digit character.
@end defun

@defun space-char-p character
Returns @code{t} when @var{character} is a white-space character (space, tab,
newline or form feed).
@end defun

@defun char-upcase character
This function returns the upper-case equivalent of @var{character}. If
@var{character} is already upper-case or has no upper-case equivalent it
is returned unchanged.

@lisp
(char-upcase ?a)
    @result{} 65                       ;`A'

(char-upcase ?A)
    @result{} 65                       ;`A'

(char-upcase ?!)
    @result{} 33                       ;`!'
@end lisp
@end defun

@defun char-downcase character
Returns the lower-case equivalent of the character @var{character}.
@end defun

@node Sequences, Symbols, Numbers, The language
@section Sequences
@cindex Sequences
@cindex Arrays

Sequences are ordered groups of objects, there are several primitive
types which can be considered sequences, each with its own good and
bad points.

A sequence is either an array or a list, where an array is either a vector
or a string.

@defun sequencep object
This function returns @code{t} if @var{object} is a sequence, @code{nil}
otherwise.
@end defun

@menu
* Cons Cells::                  An ordered pair of two objects
* Lists::                       Chains of cons cells
* Vectors::                     A chunk of memory holding a number of objects
* Strings::                     Strings are efficiently-stored vectors
* Array Functions::             Accessing elements in vectors and strings
* Sequence Functions::          These work on any type of sequence
@end menu

@node Cons Cells, Lists, , Sequences
@subsection Cons Cells
@cindex Cons cells
@cindex Sequences, cons cells

A @dfn{cons cell} is an ordered pair of two objects, the @dfn{car} and
the @dfn{cdr}.

The read syntax of a cons cell is an opening parenthesis followed by the
read syntax of the car, a dot, the read syntax of the cdr and a closing
parenthesis. For example a cons cell with a car of 10 and a cdr of
the string @samp{foo} would be written as,

@lisp
(10 . "foo")
@end lisp

@defun cons car cdr
This function creates a new cons cell. It will have a car of @var{car} and
a cdr of @var{cdr}.

@lisp
(cons 10 "foo")
    @result{} (10 . "foo")
@end lisp
@end defun

@defun consp object
This function returns @code{t} if @var{object} is a cons cell and @code{nil}
otherwise.

@lisp
(consp '(1 . 2))
    @result{} t

(consp nil)
    @result{} nil

(consp (cons 1 2))
    @result{} t
@end lisp
@end defun

@cindex Atom
In Lisp an @dfn{atom} is any object which is not a cons cell (and is,
therefore, atomic).

@defun atom object
Returns @code{t} if @var{object} is an atom (not a cons cell).
@end defun

Given a cons cell there are a number of operations which can be performed
on it.

@defun car cons-cell
This function returns the object which the car of the cons cell @var{cons-cell}.

@lisp
(car (cons 1 2))
    @result{} 1

(car '(1 . 2))
    @result{} 1
@end lisp
@end defun

@defun cdr cons-cell
This function returns the cdr of the cons cell @var{cons-cell}.

@lisp
(cdr (cons 1 2))
    @result{} 2

(cdr '(1 . 2))
    @result{} 2
@end lisp
@end defun

@defun rplaca cons-cell new-car
This function sets the value of the car in the cons cell @var{cons-cell} to
@var{new-car}. The value returned is @var{new-car}.

@lisp
(setq x (cons 1 2))
    @result{} (1 . 2)
(rplaca x 3)
    @result{} 3
x
    @result{} (3 . 2)
@end lisp
@end defun

@defun rplacd cons-cell new-cdr
This function is similar to @code{rplacd} except that the cdr slot of
@var{cons-cell} is modified.
@end defun

@node Lists, Vectors, Cons Cells, Sequences
@subsection Lists
@cindex Lists

A list is a sequence of zero or more objects, the main difference between
lists and vectors is that lists are more dynamic: they can change size,
be split, reversed, concatenated, etc@dots{} very easily.

In Lisp lists are not a primitive type; instead singly-linked lists are
created by chaining cons cells together (@pxref{Cons Cells}).

@defun listp object
This functions returns @code{t} when its argument, @var{object}, is a
list (i.e. either a cons cell or @code{nil}).
@end defun

@menu
* List Structure::              How lists are built from cons cells
* Building Lists::              Dynamically creating lists
* Accessing List Elements::     Getting at the elements which make the list
* Modifying Lists::             How to alter the contents of a list
* Association Lists::           Lists can represent relations
* Infinite Lists::              Circular data structures in Lisp
@end menu

@node List Structure, Building Lists, , Lists
@subsubsection List Structure
@cindex List structure

Each element in a list is given its own cons cell and stored in the car of
that cell. The list object is then constructed by making the cdr of a cell
contain the cons cell of the next element (and hence the whole tail of the
list). The cdr of the cell containing the last element in the list is
@code{nil}. A list of zero elements is represented by the symbol @code{nil}.

The read syntax of a list is an opening parenthesis, followed by the read
syntax of zero or more space-separated objects, followed by a closing
parenthesis. Alternatively, lists can be constructed `manually' using
dotted-pair notation.

All of the following examples result in the same list of five elements: the
numbers from zero to four.

@lisp
(0 1 2 3 4)

(0 . (1 . (2 . (3 . (4 . nil)))))

(0 1 2 . (3 4))
@end lisp

An easy way to visualise lists and how they are constructed is to see each
cons cell in the list as a separate @dfn{box} with pointers to its car and
cdr,

@example
+-----+-----+
|  o  |  o----> cdr
+--|--+-----+
   |
    --> car
@end example

Complex box-diagrams can now be drawn to represent lists. For example the
following diagram represents the list @code{(1 2 3 4)}.

@example
+-----+-----+   +-----+-----+   +-----+-----+   +-----+-----+
|  o  |  o----> |  o  |  o----> |  o  |  o----> |  o  |  o----> nil
+--|--+-----+   +--|--+-----+   +--|--+-----+   +--|--+-----+
   |               |               |               |
    --> 1           --> 2           --> 3           --> 4
@end example

A more complex example, the list @code{((1 2) (foo bar))} can be drawn as,

@example
+-----+-----+                          +-----+-----+
|  o  |  o---------------------------> |  o  |  o----> nil
+--|--+-----+                          +--|--+-----+
   |                                      |
+-----+-----+   +-----+-----+          +-----+-----+   +-----+-----+
|  o  |  o----> |  o  |  o----> nil    |  o  |  o----> |  o  |  o----> nil
+--|--+-----+   +--|--+-----+          +--|--+-----+   +--|--+-----+
   |               |                      |               |
    --> 1           --> 2                  --> foo         --> bar
@end example

Sometimes when manipulating complex list structures it is very helpful to
make a diagram of what it is that's being manipulated.

@node Building Lists, Accessing List Elements, List Structure, Lists
@subsubsection Building Lists
@cindex Building lists
@cindex Lists, building

It has already been shown how you can create lists using the Lisp reader;
this method does have a drawback though: the list created is effectively
static. If you modify the contents of the list and that list was created
when a function was defined the list will remain modified for all future
invocations of that function. This is not usually a good idea, consider
the following function definition,

@lisp
(defun bogus-function (x)
  "Return a list whose first element is nil and whose second element is X."
  (let
      ((result '(nil nil)))     ;Static list which is filled in each time
    (rplaca (cdr result) x)     ; the function is called
    result))
@end lisp

@noindent
This function does in fact do what its documentation claims, but a problem
arises when it is called more than once,

@lisp
(setq x (bogus-function 'foo))
    @result{} (nil foo)
(setq y (bogus-function 'bar))
    @result{} (nil bar)               ;The first result has been destroyed
x
    @result{} (nil bar)               ;See!
@end lisp

This example is totally contrived --- no one would ever write a function
like the one in the example but it nicely demonstrates the need for
a dynamic method of creating lists.

@defun list &rest elements
This function creates a list out of its arguments, if zero arguments are
given the empty list, @code{nil}, is returned.

@lisp
(list 1 2 3)
    @result{} (1 2 3)

(list (major-version-number) (minor-version-number))
    @result{} (3 2)

(list)
    @result{} nil               ;Equivalent to `()'
@end lisp
@end defun

@defun make-list length &optional initial-value
This function creates a list @var{length} elements long. If the
@var{initial-value} argument is given it defines the value of all elements
in the list, if it is not given they are all @code{nil}.

@lisp
(make-list 2)
    @result{} (nil nil)

(make-list 3 t)
    @result{} (t t t)

(make-list 0)
    @result{} nil
@end lisp
@end defun

@defun append &rest lists
This function creates a new list with the elements of each of its arguments
(which must be lists). Unlike the function @code{nconc} this function
preserves all of its arguments.

@lisp
(append '(1 2 3) '(4 5))
    @result{} (1 2 3 4 5)

(append)
    @result{} nil
@end lisp

What actually happens is that all arguments but the last are copied
then the last argument is linked on to the end of the list (uncopied).

@lisp
(setq foo '(1 2))
    @result{} (1 2)
(setq bar '(3 4))
    @result{} (3 4)
(setq baz (append foo bar))
    @result{} (1 2 3 4)
(eq (nthcdr 2 baz) bar)
    @result{} t
@end lisp

The following diagram shows the final state of the three variables more
clearly,

@example
foo--> +-----+-----+   +-----+-----+
       |  o  |  o----> |  o  |     |
       +--|--+-----+   +--|--+-----+
          |               |
          o--> 1          o--> 2   bar
          |               |          ->
baz--> +--|--+-----+   +--|--+-----+   +-----+-----+   +-----+-----+
       |  o  |  o----> |  o  |  o----> |  o  |  o----> |  o  |     |
       +-----+-----+   +-----+-----+   +--|--+-----+   +--|--+-----+
                                          |               |
                                           --> 3           --> 4
@end example

Note how @code{foo} and the first half of @code{baz} use the @emph{same}
objects for their elements --- copying a list only copies its cons cells, its
elements are reused. Also note how the variable @code{bar} actually
references the mid-point of @code{baz} since the last list in an @code{append}
call is not copied.
@end defun

@defun reverse list
This function returns a new list; it is made from the elements of the list
@var{list} in reverse order. Note that this function does not alter its
argument.

@lisp
(reverse '(1 2 3 4))
    @result{} (4 3 2 1)
@end lisp
@end defun

As a postscript to this section, the function used as an example at the
beginning could now be written as,

@lisp
(defun not-so-bogus-function (x)
  (list nil x))
@end lisp

Also note that the @code{cons} function can be used to create lists by hand
and to add new elements onto the front of a list.

@node Accessing List Elements, Modifying Lists, Building Lists, Lists
@subsubsection Accessing List Elements
@cindex Accessing list elements
@cindex Lists, accessing elements

The most powerful method of accessing an element in a list is via a
combination of the @code{car} and @code{cdr} functions. There are other
functions which provide an easier way to get at the elements in a flat
list. These will usually be faster than a string of @code{car} and @code{cdr}
operations.

@defun nth count list
This function returns the element @var{count} elements down the list,
therefore to access the first element use a @var{count} of zero (or even
better the @code{car} function). If there are too few elements in the list
and no element number @var{count} can be found @code{nil} is returned.

@lisp
(nth 3 '(0 1 2 3 4 5))
    @result{} 3

(nth 0 '(foo bar)
    @result{} foo
@end lisp
@end defun

@defun nthcdr count list
This function takes the cdr of the list @var{list} @var{count} times,
returning the last cdr taken.

@lisp
(nthcdr 3 '(0 1 2 3 4 5))
    @result{} (3 4 5)

(nthcdr 0 '(foo bar))
    @result{} (foo bar)
@end lisp
@end defun

@defun last list
This function returns the last element in the list @var{list}. If the
list has zero elements @code{nil} is returned.

@lisp
(last '(1 2 3))
    @result{} 3

(last '())
    @result{} nil
@end lisp
@end defun

@defun member object list
This function scans through the list @var{list} until it finds an element
which is @code{equal} to @var{object}. The tail of the list (the cons cell
whose car is the matched object) is then returned. If no elements match
@var{object} then the empty list @code{nil} is returned.

@lisp
(member 'c '(a b c d e))
    @result{} (c d e)

(member 20 '(1 2))
    @result{} nil
@end lisp
@end defun

@defun memq object list
This function is similar to @code{member} except that comparisons are
performed by the @code{eq} function not @code{equal}.
@end defun

@node Modifying Lists, Association Lists, Accessing List Elements, Lists
@subsubsection Modifying Lists
@cindex Modifying lists
@cindex Lists, modifying

The @code{nthcdr} function can be used in conjunction with the @code{rplaca}
function to modify an arbitrary element in a list. For example,

@lisp
(rplaca (nthcdr 2 '(0 1 2 3 4 5)) 'foo)
    @result{} foo
@end lisp

@noindent
sets the third element of the list @code{(0 1 2 3 4 5)} to the symbol
called @code{foo}.

There are also functions which modify the structure of a whole list. These
are called @dfn{destructive} operations because they modify the actual
structure of a list --- no copy is made. This can lead to unpleasant
side effects if care is not taken.

@defun nconc &rest lists
This function is the destructive equivalent of the function @code{append},
it modifies its arguments so that it can return a list which is the
concatenation of the elements in its arguments lists.

Like all the destructive functions this means that the lists given as
arguments are modified (specifically, the cdr of their last cons cell
is made to point to the next list). This can be seen with the
following example (similar to the example in the @code{append} documentation).

@lisp
(setq foo '(1 2))
    @result{} (1 2)
(setq bar '(3 4))
    @result{} (3 4)
(setq baz (nconc foo bar))
    @result{} (1 2 3 4)
foo
    @result{} (1 2 3 4)                ;`foo' has been altered!
(eq (nthcdr 2 baz) bar)
    @result{} t
@end lisp

The following diagram shows the final state of the three variables more
clearly,

@example
foo-->                           bar-->
baz--> +-----+-----+   +-----+-----+   +-----+-----+   +-----+-----+
       |  o  |  o----> |  o  |  o----> |  o  |  o----> |  o  |     |
       +--|--+-----+   +--|--+-----+   +--|--+-----+   +--|--+-----+
          |               |               |               |
           --> 1           --> 2             --> 3           --> 4
@end example
@end defun

@defun nreverse list
This function rearranges the cons cells constituting the list @var{list}
so that the elements are in the reverse order to what they were.

@lisp
(setq foo '(1 2 3))
    @result{} (1 2 3)
(nreverse foo)
    @result{} (3 2 1)
foo
    @result{} (1)                      ;`foo' wasn't updated when the list
                                ; was altered.
@end lisp
@end defun

@defun delete object list
This function destructively removes all elements of the list @var{list}
which are @code{equal} to @var{object} then returns the modified list.

@lisp
(delete t '(nil t nil t nil))
    @result{} (nil nil nil)
@end lisp

When this function is used to remove an element from a list which is stored
in a variable that variable must be set to the return value of the
@code{delete} function. Otherwise, if the first element of the list
has to be deleted (because it is @code{equal} to @var{object}) the value
of the variable will not change.

@lisp
(setq foo '(1 2 3))
    @result{} (1 2 3)
(delete 1 foo)
    @result{} (2 3)
foo
    @result{} (1 2 3)
(setq foo (delete 1 foo))
    @result{} (2 3)
@end lisp
@end defun

@defun delq object list
This function is similar to the @code{delete} function, the only difference
is that the @code{eq} function is used to compare @var{object} with each
of the elements in @var{list}, instead of the @code{equal} function which
is used by @code{delete}.
@end defun

@node Association Lists, Infinite Lists, Modifying Lists, Lists
@subsubsection Association Lists
@cindex Association lists
@cindex Alists
@cindex Lists, association

An @dfn{association list} (or @dfn{alist}) is a list mapping key values to
to other values. Each element of the alist is a cons cell, the car of which
is the @dfn{key}, the cdr is the value that it associates to. For example
an alist could look like,

@lisp
((fred . 20)
 (bill . 30))
@end lisp

@noindent
this alist has two keys, @code{fred} and @code{bill} which both associate
to an integer (20 and 30 respectively).

It is possible to make the associated values lists, this looks like,

@lisp
((fred 20 male)
 (bill 30 male)
 (sue  25 female))
@end lisp

@noindent
in this alist the symbol @code{fred} is associated with the list
@code{(20 male)}.

There are a number of functions which let you interrogate an alist with
a given key for its association.

@defun assoc key alist
This function scans the association list @var{alist} for the first element
whose car is @code{equal} to @var{key}, this element is then returned. If
no match of @var{key} is found @code{nil} is returned.

@lisp
(assoc 'two '((one . 1) (two . 2) (three . 3)))
    @result{} (two . 2)
@end lisp
@end defun

@defun assq key alist
Similar to the function @code{assoc} except that the function @code{eq} is
used to compare elements instead of @code{equal}.

It is not usually wise to use @code{assq} when the keys of the alist may not
be symbols --- @code{eq} won't think two objects are equivalent unless they
are the @emph{same} object!

@lisp
(assq "foo" '(("bar" . 1) ("foo" . 2)))
    @result{} nil
(assoc "foo" '(("bar" . 1) ("foo" . 2)))
    @result{} ("foo" . 2)
@end lisp
@end defun

@defun rassoc association alist
This function searches through @var{alist} until it finds an element whose
cdr is @code{equal} to @var{association}, that element is then returned.
@code{nil} will be returned if no elements match.

@lisp
(rassoc 2 '((one . 1) (two . 2) (three . 3)))
    @result{} (two . 2)
@end lisp
@end defun

@defun rassq association alist
This function is equivalent to @code{rassoc} except that it uses @code{eq}
to make comparisons.
@end defun

@node Infinite Lists, , Association Lists, Lists
@subsubsection Infinite Lists
@cindex Infinite lists
@cindex Circular lists
@cindex Lists, circular

Sometimes it is useful to be able to create `infinite' lists --- that is,
lists which appear to have no last element --- this can easily be done
in Lisp by linking the cdr of the last cons cell in the list structure
back to the beginning of the list.

@example
 ----------------------------------- 
|                                   |
 --> +-----+-----+   +-----+-----+  |
     |  o  |  o----> |  o  |  o----- 
     +--|--+-----+   +--|--+-----+
        |               |
         --> 1           --> 2
@end example

The diagram above represents the infinite list @code{(1 2 1 2 1 2 @dots{})}.

Infinite lists have a major drawback though, many of the standard list
manipulation functions can not be used on them. These functions work by
moving through the list until they reach the end. If the list has @emph{no}
end the function may never terminate and the only option is to send Jade an
interrupt signal (@pxref{Interrupting Jade}).

The only functions which may be used on circular lists are: the cons cell
primitives (@code{cons}, @code{car}, @code{cdr}, @code{rplaca}, @code{rplacd}),
@code{nth} and @code{nthcdr}.

Also note that infinite lists can't be printed.

@node Vectors, Strings, Lists, Sequences
@subsection Vectors

A vector is a fixed-size sequence of Lisp objects, each element may be
accessed in constant time --- unlike lists where the time taken to access
an element is proportional to the position of the element.

The read syntax of a vector is an opening square bracket, followed by zero
or more space-separated objects, followed by a closing square bracket. For
example,

@lisp
[zero one two three]
@end lisp

In general it is best to use vectors when the number of elements to be
stored is known and lists when the sequence must be more dynamic.

@defun vectorp object
This function returns @code{t} if its argument, @var{object}, is a vector.
@end defun

@defun vector &rest elements
This function creates a new vector containing the arguments given to the
function.

@lisp
(vector 1 2 3)
    @result{} [1 2 3]

(vector)
    @result{} []
@end lisp
@end defun

@defun make-vector size &optional initial-value
Returns a new vector, @var{size} elements big. If @var{initial-value} is
defined each element of the new vector is set to @var{initial-value}, otherwise
they are all @code{nil}.

@lisp
(make-vector 4)
    @result{} [nil nil nil nil]

(make-vector 2 t)
    @result{} [t t]
@end lisp
@end defun

@node Strings, Array Functions, Vectors, Sequences
@subsection Strings

A string is a vector of characters (@pxref{Characters}), they are generally
used for storing and manipulating pieces of text. Jade puts no restrictions
on the values which may be stored in a string --- specifically, the null
character (@samp{^@@}) may be stored with no problems.

The read syntax of a string is a double quote character, followed by the
contents of the string, the object is terminated by a second double quote
character. For example, @code{"abc"} is the read syntax of the string
@samp{abc}.

@cindex Escape sequences in strings
@cindex Strings, escape sequences
Any backslash characters in the string's read syntax introduce an escape
sequence; one or more of the following characters are treated specially to
produce the next @emph{actual} character in the string.

The following escape sequences are supported (all are shown without their
leading backslash @samp{\} character).

@table @samp
@item n
A newline character.

@item r
A carriage return character.

@item f
A form feed character.

@item t
A TAB character.

@item a
A `bell' character (this is Ctrl-g).

@item ^@var{c}
The `control' code of the character @var{c}. This is calculated by toggling
the seventh bit of the @emph{upper-case} version of @var{c}.

For example,

@lisp
\^C             ;A Ctrl-c character (ASCII value 3)
\^@@            ;The NUL character (ASCII value 0)
@end lisp

@item 012
The character whose ASCII value is the octal value @samp{012}. After the
backslash character the Lisp reader reads up to three octal digits and
combines them into one character.

@item x12
The character whose ASCII value is the hexadecimal value @samp{12}, i.e.
an @samp{x} character followed by one or two hex digits.
@end table

@defun stringp object
This function returns @code{t} if its argument is a string.
@end defun

@defun make-string length &optional initial-character
Creates a new string containing @var{length} characters, each character
is initialised to @var{initial-character} (or to spaces if
@var{initial-character} is not defined).

@lisp
(make-string 3)
    @result{} "   "

(make-string 2 ?$)
    @result{} "$$"
@end lisp
@end defun

@defun concat &rest args
This function concatenates all of its arguments, @var{args}, into a single
string which is returned. If no arguments are given then the null string
(@samp{}) results.

Each of the @var{args} may be a string, a character or a list or vector of
characters. Characters are stored in strings modulo 256.

@lisp
(concat "foo" "bar")
    @result{} "foobar"

(concat "a" ?b)
    @result{} "ab"

(concat "foo" [?b ?a ?r])
    @result{} "foobar"

(concat)
    @result{} ""
@end lisp
@end defun

@defun substring string start &optional end
This function creates a new string which is a partial copy of the string
@var{string}. The first character copied is @var{start} characters from
the beginning of the string. If the @var{end} argument is defined it is
the index of the character to stop copying at, if it is not defined
all characters until the end of the string are copied.

@lisp
(substring "xxyfoozwx" 3 6)
    @result{} "foo"

(substring "xyzfoobar" 3)
    @result{} "foobar"
@end lisp
@end defun

@defun string= string1 string2
This function compares the two strings @var{string1} and @var{string2} --- if
they are made from the same characters in the same order then @code{t} is
returned, else @code{nil}.

@lisp
(string= "one" "one")
    @result{} t

(string= "one" "two")
    @result{} nil
@end lisp

Note that an alternate way to compare strings (or anything!) is to use the
@code{equal} function.
@end defun

@defun string< string1 string2
This function returns @code{t} if @var{string1} is `less' than @code{string2}.
This is determined by comparing the two strings a character at a time, the
first pair of characters which do not match each other are then compared
with a normal `less-than' function.

In Jade the standard @code{<} function understands strings so @code{string<}
is just a macro calling that function.

@lisp
(string< "abc" "abd")
    @result{} t

(string< "abc" "abb")
    @result{} nil
@end lisp
@end defun

Functions are also available which match regular expressions with strings
(@pxref{Search and Match Functions}) and which apply a mapping to each
character in a string (@pxref{Translation Functions}).

@node Array Functions, Sequence Functions, Strings, Sequences
@subsection Array Functions
@cindex Array functions

@defun arrayp object
This function returns @code{t} if @var{object} is an array.
@end defun

@defun aref array position
Returns the element of the array (vector or string) @var{array} @var{position}
elements from the first element (i.e. the first element is numbered zero).
If no element exists at @var{position} in @var{array}, @code{nil} is
returned.

@lisp
(aref [0 1 2 3] 2)
    @result{} 2

(aref "abcdef" 3)
    @result{} 100                      ;`d'
@end lisp
@end defun

@defun aset array position value
This function sets the element of the array @var{array} with an index of
@var{position} (counting from zero) to @var{value}. An error is signalled
if element @var{position} does not exist. The result of the function is
@var{value}.

@lisp
(setq x [0 1 2 3])
    @result{} [0 1 2 3]
(aset x 2 'foo)
    @result{} foo
x
    @result{} [0 1 foo 3]
@end lisp
@end defun

@node Sequence Functions, , Array Functions, Sequences
@subsection Sequence Functions
@cindex Sequence functions

@defun length sequence
This function returns the length (an integer) of the sequence @var{sequence}.

@lisp
(length "abc")
    @result{} 3

(length '(1 2 3 4))
    @result{} 4

(length [x y])
    @result{} 2
@end lisp
@end defun

@defun copy-sequence sequence
Returns a new copy of the sequence @var{sequence}. Where possible (in lists
and vectors) only the `structure' of the sequence is newly allocated: the
same objects are used for the elements in both sequences.

@lisp
(copy-sequence "xy")
    @result{} "xy"

(setq x '("one" "two"))
    @result{} ("one" "two")
(setq y (copy-sequence x))
    @result{} ("one" "two")
(eq x y)
    @result{} nil
(eq (car x) (car y))
    @result{} t
@end lisp
@end defun

@defun elt sequence position
This function returns the element of @var{sequence} @var{position} elements
from the beginning of the sequence.

This function is a combination of the @code{nth} and @code{aref} functions.

@lisp
(elt [0 1 2 3] 1)
    @result{} 1

(elt '(foo bar) 0)
    @result{} foo
@end lisp
@end defun

@node Symbols, Evaluation, Sequences, The language
@section Symbols
@cindex Symbols

Symbols are objects with a name (usually a unique name), they are one of
the most important data structures in Lisp since they are used to
provided named variables (@pxref{Variables}) and functions (@pxref{Functions}).

@defun symbolp object
This function returns @code{t} when its argument is a symbol.
@end defun

@menu
* Symbol Syntax::               The read syntax of symbols
* Symbol Attributes::           The objects stored in a symbol
* Obarrays::                    Vectors used to store symbols
* Creating Symbols::            Allocating new symbols
* Interning::                   Putting a symbol into an obarray
* Property Lists::              Each symbol has a set of properties
@end menu

@node Symbol Syntax, Symbol Attributes, , Symbols
@subsection Symbol Syntax
@cindex Symbol syntax

The read syntax of a symbol is simply its name; if the name contains
any meta-characters (whitespace or any from @samp{()[]'";|}) they will have
to be entered specially. There are two ways to tell the reader that a
meta-character is actually part of the symbol's name:

@enumerate
@item
Precede the meta-character by a backslash character (@samp{\}), for example:

@lisp
xy\(z\)                 ;the symbol whose name is @samp{xy(z)}
@end lisp

@item
Enclose part of the name in vertical lines (two @samp{|} characters). All
characters after the starting vertical line are copied as-is until the
closing vertical line is encountered. For example:

@lisp
xy|(z)|                 ;the symbol @samp{xy(z)}
@end lisp
@end enumerate

Here are some example read syntaxes.

@lisp
setq                    ; @samp{setq}
|setq|                  ; @samp{setq}
\s\e\t\q                ; @samp{setq}
1                       ; the @emph{number} 1
\1                      ; the @emph{symbol} @samp{1}
|!$%zf78&|              ; @samp{!$%zf78&}
foo|(bar)|              ; @samp{foo(bar)}
foo\(bar\)              ; @samp{foo(bar)}
@end lisp

@node Symbol Attributes, Obarrays, Symbol Syntax, Symbols
@subsection Symbol Attributes
@cindex Symbol attributes

All symbols have four basic attributes, most important is the @dfn{print name}
of the symbol. This is a string containing the name of the symbol, after it
has been defined (when the symbol is first created) it may not be changed.

@defun symbol-name symbol
This function returns the print name of the symbol @var{symbol}.

@lisp
(symbol-name 'unwind-protect)
    @result{} "unwind-protect"
@end lisp
@end defun

Each symbol also has a @dfn{value} cell storing the value of this symbol when
it is referenced as a variable. Usually this cell is accessed implicitly by
evaluating a variable form but it can also be read via the @code{symbol-value}
function@footnote{Actually buffer-local variables complicate matters but
you'll learn about that later.} (@pxref{Variables}).

Similar to the value cell each symbol also has a @dfn{function} cell which
contains the function definition of the symbol (@pxref{Named Functions}). The
@code{symbol-function} function can be used to read this cell and the
@code{fset} function to set it.

Lastly, there is the symbol's @dfn{property list}, this is similar to an
alist (@pxref{Association Lists}) and provides a method of storing arbitrary
extra values in each symbol. @xref{Property Lists}.

@node Obarrays, Creating Symbols, Symbol Attributes, Symbols
@subsection Obarrays
@cindex Obarrays
@cindex Symbols, obarrays

An @dfn{obarray} is the structure used to ensure that no two symbols have
the same name and to provide quick access to a symbol given its name. An
obarray is basically a vector (with a slight wrinkle), each element of
the vector is a chain of symbols which share the same hash-value (a
@dfn{bucket}). These symbols are chained together through links which
are invisible to Lisp programs: if you examine an obarray you will see that
each bucket looks as though it has at most one symbol stored in it.

The normal way to reference a symbol is simply to type its name in the
program, when the Lisp reader encounters a name of a symbol it looks
in the default obarray for a symbol of that name. If the named symbol
doesn't exist it is created and hashed into the obarray --- this
process is known as @dfn{interning} the symbol, for more details see
@ref{Interning}.

@defvar obarray
This variable contains the obarray that the @code{read} function uses when
interning symbols. If you change this I hope you know what you're doing.
@end defvar

@defun make-obarray size
This function creates a new obarray with @var{size} hash buckets (this
should be a prime number for best results).

This is the only correct way of making an obarray.
@end defun

@defun find-symbol symbol-name &optional obarray
This function scans the specified obarray (@var{obarray} or the value of
the variable @code{obarray} if @var{obarray} is undefined) for a symbol
whose name is the string @var{symbol-name}. The value returned is the
symbol if it can be found or @code{nil} otherwise.

@lisp
(find-symbol "setq")
    @result{} setq
@end lisp
@end defun

@defun apropos regexp &optional predicate obarray
Returns a list of symbols from the obarray @var{obarray} (or the default)
whose print name matches the regular expression @var{regexp}. If
@var{predicate} is defined and not @code{nil}, each symbol which matches
@var{regexp} is applied to the function @var{predicate}, if the value
is @code{t} it is considered a match.

The @var{predicate} argument is useful for restricting matches to a certain
type of symbol, for example only commands.

@lisp
(apropos "^yank" 'commandp)
    @result{} (yank-rectangle yank yank-to-mouse)
@end lisp
@end defun

@node Creating Symbols, Interning, Obarrays, Symbols
@subsection Creating Symbols
@cindex Creating symbols
@cindex Symbols, creating

It is possible to allocate symbols dynamically, this is normally only
necessary when the symbol is to be interned in the non-default obarray
or the symbol is a temporary object which should not be interned (for
example: labels in a compiler?).

@defun make-symbol print-name
This function creates and returns a new, uninterned, symbol whose print
name is the string @var{print-name}. Its variable and function value cells
are void and it will have an empty property list.

@lisp
(make-symbol "foo")
    @result{} foo
@end lisp
@end defun

@defun gensym
This function returns a new, uninterned, symbol which has a unique print
name.

@lisp
(gensym)
    @result{} G0001

(gensym)
    @result{} G0002
@end lisp
@end defun

@node Interning, Property Lists, Creating Symbols, Symbols
@subsection Interning
@cindex Interning
@cindex Symbols, interning

@dfn{Interning} a symbol means to store it in an obarray so that it can
be found in the future: all variables and named-functions are stored in
interned symbols.

When a symbol is interned a hash function is applied to its print name to
determine which bucket in the obarray it should be stored in. Then it is
simply pushed onto the front of that bucket's chain of symbols.

Normally all interning is done automatically by the Lisp reader. When it
encounters the name of a symbol which it can't find in the default obarray
(the value of the variable @code{obarray}) it creates a new symbol of that
name and interns it. This means that no two symbols can have the same print
name, and that the read syntax of a particular symbol always produces the
same object (unless the value of @code{obarray} is altered).

@lisp
(eq 'some-symbol 'some-symbol)
    @result{} t
@end lisp

@defun intern symbol-name &optional obarray
This function uses @code{find-symbol} to search the @var{obarray} (or the
standard obarray) for a symbol called @var{symbol-name}. If a symbol of
that name is found it is returned, otherwise a new symbol of that name is
created, interned into the obarray, and returned.

@lisp
(intern "setq")
    @result{} setq

(intern "my-symbol" my-obarray)
    @result{} my-symbol
@end lisp
@end defun

@defun intern-symbol symbol &optional obarray
Interns the symbol @var{symbol} into the obarray @var{obarray} (or the
standard one) then returns the symbol. If @var{symbol} is currently
interned in an obarray an error is signalled.

@lisp
(intern-symbol (make-symbol "foo"))
    @result{} foo

(intern-symbol 'foo)
    @error{} Error: Symbol is already interned, foo
@end lisp
@end defun

@defun unintern symbol &optional obarray
This function removes the symbol @var{symbol} from the obarray @var{obarray}
then returns the symbol.

Beware! this function must be used with @emph{extreme} caution --- once you
unintern a symbol there's no way to recover it.

@lisp
(unintern 'setq)                ;This is extremely stupid
    @result{} setq
@end lisp
@end defun

@node Property Lists, , Interning, Symbols
@subsection Property Lists
@cindex Property lists
@cindex Symbols, property lists

Each symbol has a property list (or @dfn{plist}), this is a structure which
associates an arbitrary Lisp object with a key (usually a symbol). The
keys in a plist may not have any duplications (so that each property is
only defined once).

The concept of a property list is very similar to an association list
(@pxref{Association Lists}) but there are two main differences:

@enumerate
@item
Structure; each element of an alist represents one key/association pair. In
a plist each pair of elements represents an association: the first
is the key, the second the property. For example, where an alist may
be,

@lisp
((one . 1) (two . 2) (three . 3))
@end lisp

@noindent
a property list would be,

@lisp
(one 1 two 2 three 3)
@end lisp

@item
Plists have their own set of functions to modify the list. This is done
destructively, altering the property list (since the plist is stored in
only one location, the symbol, this is quite safe).
@end enumerate

@defun get symbol property
This function searches the property list of the symbol @var{symbol} for
a property @code{eq} to @var{property}. If such a property is found it
is returned, else the value @code{nil} is returned.

@lisp
(get 'if 'lisp-indent)
    @result{} 2

(get 'set 'lisp-indent)
    @result{} nil
@end lisp
@end defun

@defun put symbol property new-value
@code{put} sets the value of the property @var{property} to @var{new-value}
in the property list of the symbol @var{symbol}. If there is an
existing value for this property it is overwritten. The value returned
is @var{new-value}.

@lisp
(put 'foo 'prop 200)
    @result{} 200
@end lisp
@end defun

@defun symbol-plist symbol
Returns the property list of the symbol @var{symbol}.

@lisp
(symbol-plist 'if)
    @result{} (lisp-indent 2)
@end lisp
@end defun

@defun setplist symbol plist
This function sets the property list of the symbol @var{symbol} to
@var{plist}.

@lisp
(setplist 'foo '(zombie yes))
    @result{} (zombie yes)
@end lisp
@end defun

@node Evaluation, Control Structures, Symbols, The language
@section Evaluation
@cindex Evaluation
@cindex Evaluating Lisp forms
@cindex Lisp forms, evaluating

So far I have only discussed a few of the various data types available
and how the Lisp reader can convert textual descriptions of these types
into Lisp objects. Obviously there has to be a way of actually computing
something --- it would be difficult to write a useful program otherwise.

What sets Lisp apart from other languages is that in Lisp there is no
difference between programs and data: a Lisp program is just a
sequence of Lisp objects which will be interpreted when the program
is run.

The subsystem which does this interpreting is called the
@dfn{Lisp evaluator} and each expression to be evaluated is called
a @dfn{form}. The evaluator (the function @code{eval}) examines the
structure of the form that is applied to and computes the value of the
form within the current environment.

A form can be any type of data object; the only types which
the evaluator treats specially are symbols (which stand for variables)
and lists, anything else is returned as-is (and is called a
@dfn{self-evaluating form}).

@defun eval form
This function computes the value of the form which is its argument, within
the current environment. The computed value is then returned.
@code{eval} is the basic function for interpreting Lisp objects.
@end defun

@menu
* Symbol Forms::                How variables are accessed
* List Forms::                  Subroutine calls
* Self-Evaluating Forms::       Forms which don't get evaluated
* Quoting::                     How to prevent evaluation of forms
@end menu

@node Symbol Forms, List Forms, , Evaluation
@subsection Symbol Forms
@cindex Symbol forms
@cindex Forms, symbol
@cindex Forms, variable

When the evaluator is applied to a symbol the computed value of the form
is the object stored in the symbol's variable slot. Basically this means
that to get the value of a variable you simply write its name. For example,

@lisp
buffer-list
    @result{} (#<buffer *jade*> #<buffer programmer.texi>)
@end lisp

@noindent
this extract from a Lisp session shows the read syntax of a form to
get the value of the variable @code{buffer-list} and the result when
this form is evaluated.

Since forms are evaluated within the current environment the value of
a variable is its newest binding, or in the case of buffer-local variables,
its value in the current buffer. @xref{Variables}.

If the value of an evaluated symbol is void an error is signalled.

@node List Forms, Self-Evaluating Forms, Symbol Forms, Evaluation
@subsection List Forms
@cindex List forms

Forms which are lists are used to call a subroutine. The first element
of the list is the subroutine which is to be called; all further elements
are arguments to be applied to the subroutine.

There are several different types of subroutines available: functions,
macros, special forms and autoloads. When the evaluator finds a form
which is a list it tries to classify the form into one of these four types.
First of all it looks at the first element of the list, if it is a symbol
it gets the value from the function slot of the symbol (note that the
first element of a list form is @emph{never} evaluated itself). This value
(either the first element or the symbol's function value) is enough
to classify the form into one of the four types.

@menu
* Function Call Forms::         `Normal' subroutines
* Macro Call Forms::            Source code expansions
* Special Forms::               Abnormal control structures
* Autoload Forms::              Loading subroutines from files on the fly
@end menu

@node Function Call Forms, Macro Call Forms, , List Forms
@subsubsection Function Call Forms
@cindex Function call forms
@cindex Forms, function call

The first element of a function call form is the name of the function, this
can be either a symbol (in which case the symbol's function value is
indirected through to get the real function definition) or a lambda
expression (@pxref{Lambda Expressions}).

Any other elements of the list are forms to be evaluated (in left to
right order) and their values become the arguments to the function. The
function is applied to these arguments and the result that it returns
becomes the value of the form.

For example, consider the form @code{(/ 100 (1+ 4))}. This is a function
call to the function @code{/}. First the @code{100} form is evaluated: it
returns the value @code{100}, next the form @code{(1+ 4)} is evaluated. This
is also a function call and computes to a value of @code{5} which becomes
the second argument to the @code{/} function. Now the @code{/} function is
applied to its arguments of @code{100} and @code{5} and it returns the
value @code{20} which then becomes the value of the form @code{(/ 100 (1+ 4))}.

@lisp
(/ 100 (1+ 4))
@equiv{} (/ 100 5)
@result{} 20
@end lisp

Or another example,

@lisp
(+ (- 10 (1- 7)) (* (1+ 2) 4)
@equiv{} (+ (- 10 6) (* (1+ 2) 4)
@equiv{} (+ 4 (* (1+ 2) 4)
@equiv{} (+ 4 (* 3 4))
@equiv{} (+ 4 12)
@result{} 16
@end lisp

@node Macro Call Forms, Special Forms, Function Call Forms, List Forms
@subsubsection Macro Call Forms
@cindex Macro call forms
@cindex Forms, macro call

Macros are source code expansions, the general idea is that a macro
is a function which using the unevaluated arguments applied to it,
computes another form (the expansion of the macro and its arguments)
which is then evaluated to provide the value of the form. For more
details see @ref{Macros}.

@node Special Forms, Autoload Forms, Macro Call Forms, List Forms
@subsubsection Special Forms
@cindex Special forms
@cindex Forms, special

Special forms are built-in functions which the evaluator knows must be
handled specially. The main difference between a special form and a function
is that the arguments applied to a special form are @emph{not} automatically
evaluated --- if necessary the special form will evaluate arguments itself.
This will be noted in the documentation of the special form.

Special forms are generally used to provide control structures, for example,
all of the conditional constructs are special forms (if all of their arguments,
including the forms to be conditionally evaluated, were evaluated automatically
this would defeat the object of being conditional!).

The special forms supported by Jade are: @code{and}, @code{catch}, @code{cond},
@code{defconst}, @code{defmacro}, @code{defun}, @code{defvar},
@code{error-protect}, @code{function}, @code{if}, @code{let}, @code{let*},
@code{or}, @code{prog1}, @code{prog2}, @code{progn}, @code{quote}, @code{setq},
@code{setq-default}, @code{unless}, @code{unwind-protect}, @code{when},
@code{while}, @code{with-buffer}, @code{with-window}.

@node Autoload Forms, , Special Forms, List Forms
@subsubsection Autoload Forms
@cindex Autoload forms
@cindex Forms, autoload

Not all modules of Jade are needed at once, autoload forms provide a
means of marking that a function (or macro) is contained by a specific
file of Lisp code. The first time that the function is accessed the
autoload form will be evaluated; this loads the file that the function
is contained by then re-evaluates the list form.

By then the autoload form will have been overwritten in the symbol's
function slot by the true function (when it was loaded) so the form
will execute properly.

An autoload form is a list whose first element is the symbol @code{autoload},
for full details see @ref{Autoloading}.

@node Self-Evaluating Forms, Quoting, List Forms, Evaluation
@subsection Self-Evaluating Forms
@cindex Self-evaluating forms
@cindex Forms, self-evaluating
@cindex Forms, constant

The computed value of any form which is not a symbol or a list will
simply be the form itself and the form is said to be a @dfn{self-evaluating
form}.

Usually the only forms to be evaluated in this way will be numbers, strings
and vectors (since they are the only other data types which have read
syntaxes) but the effect is the same for other types of data.

This means that forms you know are self-evaluating do not have to be
quoted to be used as constants (like lists and symbols do).

@lisp
"foo"
    @result{} "foo"

(eval (current-buffer))
    @result{} #<buffer programmer.texi>
@end lisp

@node Quoting, , Self-Evaluating Forms, Evaluation
@subsection Quoting
@cindex Quoting

As the above sections explain some types of Lisp object have special
meaning to the Lisp evaluator (namely the symbol and list types) this
means that if you want to refer to a symbol or a list in a program you
can't (yet) because the evaluator will treat the form as either a
variable reference or a function call respectively.

To get around this Lisp uses something called @dfn{quoting}, the
@code{quote} special form simply returns its argument, without evaluating
it. For example,

@lisp
(quote my-symbol)
    @result{} my-symbol
@end lisp

@noindent
the @code{quote} form prevents the @code{my-symbol} being treated as a
variable --- it is effectively `hidden' from the evaluator.

Writing @samp{quote} all the time would be a bit boring so there is a
shortcut: the Lisp reader treats any form @var{x} preceded by a single quote
character (@samp{'}) as the form @code{(quote @var{x})}. So the example
above would normally be written as,

@lisp
'my-symbol
    @result{} my-symbol
@end lisp

@defspec quote form
This special form returns its single argument without evaluating it. This
is used to @dfn{quote} constant objects to prevent them from being
evaluated.
@end defspec

@node Control Structures, Variables, Evaluation, The language
@section Control Structures
@cindex Control Structures

Control structures are special forms or macros which control which forms
get evaluated, when they get evaluated and the number of times to
evaluate them. This includes conditional structures, loops, etc@dots{}

The simplest control structures are the sequencing structures; they are
used to evaluate a list of forms in left to right order.

@menu
* Sequencing Structures::       Evaluating several forms in sequence
* Conditional Structures::      Making decisions based on truth values
* Looping Structures::          `while' loops
* Non-Local Exits::             Exiting from several levels of evaluation
@end menu

@node Sequencing Structures, Conditional Structures, , Control Structures
@subsection Sequencing Structures
@cindex Sequencing structures
@cindex Control structures, sequencing

Each of the special forms in this section simply evaluates its argument
forms in left-to-right order. The only difference is the result they return.

The most widely used sequencing special form is @code{progn}: it
evaluates all its argument forms and returns the computed value of the last
one. Many other control structures are said to perform an @dfn{implicit progn},
this means that they call @code{progn} with a list of forms.

@code{progn} in Lisp is nearly analogous to a @code{begin@dots{}end} block
in Pascal; it is used in much the same places --- to allow you to
evaluate a sequence of form where only one form was allowed (for example
the true clause of an @code{if} structure).

@defspec progn forms@dots{}
All of the @var{forms} are evaluated sequentially (from left-to-right),
the result of the last evaluated @var{form} is the return value of this
structure. If no arguments are given to @code{progn} it returns @code{nil}.

@lisp
(progn 'one (+ 1 1) "three")
    @result{} "three"

(progn)
    @result{} nil
@end lisp
@end defspec

@defspec prog1 first forms@dots{}
This special form evaluates its @var{first} form then performs an
implicit progn on the rest of its arguments. The result of this
structure is the computed value of the first form.

@lisp
(prog1 'one (+ 1 1) "three")
    @result{} one
@end lisp
@end defspec

@defspec prog2 first second forms@dots{}
This is similar to @code{prog1} except that the evaluated value of
its @var{second} form is returned.

The @var{first} form is evaluated, then its @var{second}, then it
performs an implicit progn on the remaining arguments.

@lisp
(prog2 'one (+ 1 1) "three")
    @result{} 2
@end lisp
@end defspec

@node Conditional Structures, Looping Structures, Sequencing Structures, Control Structures
@subsection Conditional Structures
@cindex Conditional structures
@cindex Control structures, conditionals

Lisp provides a number of conditional constructs, the most complex of
which (@code{cond}) will take a list of conditions, the first of which
is @code{t} then has its associated list of forms evaluated. Theoretically
this is the only conditional special form necessary --- the rest could
be implemented as macros.

@defspec if condition true-form else-forms@dots{}
The @code{if} construct is the nearest thing in Lisp to the @dfn{if-then-else}
construct found in most programming languages.

First the @var{condition} form is evaluated, if it returns @code{t} (not
@code{nil}) the @var{true-form} is evaluated and its result returned. Otherwise
the result of an implicit progn on the @var{else-forms} is returned. If there
are no @var{else-forms} @code{nil} is returned.

Note that one of the @var{true-form} or the @var{else-forms} is completely
ignored --- it is not evaluated.

@lisp
(if (special-form-p 'if)
    "`if' is a special form"
  "`if' is not a special form")
    @result{} "`if' is a special form"
@end lisp
@end defspec

@defspec when condition true-forms@dots{}
@var{condition} is evaluated, if it is @code{t} the result of an implicit progn
on the @var{true-forms} is returned, otherwise @code{nil} is returned.

@lisp
(when t
  (message "Pointless")
  'foo)
    @result{} foo
@end lisp
@end defspec

@defspec unless condition else-forms@dots{}
This special forms first evaluates @var{condition}, if its computed value is
not @code{nil} its value is returned. Otherwise the @var{else-forms} are
evaluated sequentially, the value of the last is returned.
@end defspec

@defspec cond clause@dots{}
The @code{cond} special form is used to choose between an arbitrary number
of conditions. Each @var{clause} is a list; its car is the @var{condition}
the list which is the cdr of the @var{clause} is the @var{body-forms}. This
means that each @var{clause} looks something like:

@lisp
(@var{condition} @var{body-forms}@dots{})
@end lisp

@noindent
and a whole @code{cond} form looks like:

@lisp
(cond
 (@var{condition-1} @var{body-forms-1}@dots{})
 (@var{condition-2} @var{body-forms-2}@dots{})
 @dots{})
@end lisp

The @var{condition} in each @var{clause} is evaluated in sequence
(@var{condition-1}, then @var{condition-2}, @dots{}), the first one
which evaluates to a non-@code{nil} has an implicit progn performed on
its @var{body-forms}, the value of which is the value returned by the
@code{cond} form.

If the true @var{condition} has no @var{body-forms} the value returned
by @code{cond} is the value of the @var{condition}. If none of the
clauses has a non-@code{nil} @var{condition} the value of the @code{cond}
is @code{nil}.

Often you want a @dfn{default} clause; one which has its @var{body-forms}
to be evaluated if none of the other clauses are true. The way to
do this is to add a clause with a @var{condition} of @code{t} and
@var{body-forms} of whatever you want the default action to be.

@lisp
(cond
 ((stringp buffer-list))        ;Clause with no @var{body-forms}
 ((consp buffer-list)
  (setq x buffer-list)          ;Two @var{body-forms}
  t)
 (t                             ;Default clause
  (error "`buffer-list' is corrupted!")))
    @result{} t
@end lisp

All of the other conditionals can be written in terms of @code{cond},

@lisp
(if @var{c} @var{t} @var{e}@dots{}) @equiv{} (cond (@var{c} @var{t}) (t @var{e}@dots{}))

(when @var{c} @var{t}@dots{}) @equiv{} (cond (@var{c} @var{t}@dots{}))

(unless @var{c} @var{e}@dots{}) @equiv{} (cond (@var{e}) (t @var{e}@dots{}))
@end lisp
@end defspec

There are also a number of special forms which combine conditions together
by the normal logical rules.

@defspec or forms@dots{}
The first of the @var{forms} is evaluated, if it is non-@code{nil} its value
becomes the value of the @code{or} form and no more of @code{forms} are
evaluated. Otherwise this step is repeated for the next member of @var{forms}.

If all of the @var{forms} have been evaluated and none have a non-@code{nil}
value @code{nil} becomes the value of the @code{or} form.

If there are no @var{forms} @code{nil} is returned.

@lisp
(or nil 1 nil (beep))           ;@code{(beep)} won't be evaluated
    @result{} 1
@end lisp
@end defspec

@defspec and forms@dots{}
The first of the @var{forms} is evaluated. If it is @code{nil} no more
of the @var{forms} are evaluated and @code{nil} becomes the value of the
@code{and} structure. Otherwise the next member of @var{forms} is evaluated
and its value tested. If none of the @var{forms} are @code{nil} the computed
value of the last member of @var{forms} becomes the value of the @code{and}
form.

@lisp
(and 1 2 nil (beep))            ;@code{(beep)} won't be evaluated
    @result{} nil

(and 1 2 3)                     ;All forms are evaluated
    @result{} 3
@end lisp
@end defspec

@defun not object
This function inverts the boolean value of its argument. If @var{object}
is non-@code{nil}, @code{nil} is returned, otherwise @code{t} is returned.

@lisp
(not nil)
    @result{} t

(not t)
    @result{} nil

(not 42)
    @result{} nil
@end lisp
@end defun

@node Looping Structures, Non-Local Exits, Conditional Structures, Control Structures
@subsection Looping Structures
@cindex Looping structures
@cindex Control structures, looping

Jade's version of Lisp has only one structure for looping --- a @dfn{while}
loop similar to those found in most programming languages.

@defspec while condition body-forms@dots{}
The @var{condition} form is evaluated. If it is non-@code{nil} an implicit
progn is performed on the @var{body-forms} and the whole thing is repeated
again.

This continues until the @var{condition} form evaluates to @code{nil}. The
value of any @code{while} structure is @code{nil}.

@code{while} can be recursively defined in terms of @code{when}:

@lisp
(while @var{c} @var{b} @dots{})
@equiv{}
(when @var{c} (progn @var{b} @dots{} (while @var{c} @var{b} @dots{})))
@end lisp

@lisp
;; Step through a list @var{x}
(while @var{x}
  ;; Do something with the current element, @code{(car @var{x})}
  (setq @var{x} (cdr @var{x})))
@end lisp
@end defspec

@node Non-Local Exits, , Looping Structures, Control Structures
@subsection Non-Local Exits
@cindex Non-local exits
@cindex Control structures, non-local exits

A @dfn{non-local exit} is a transfer of control from the current point
of evaluation to a different point (somewhat similar to the much-maligned
@code{goto} statement in some imperative languages).

Non-local exits can either be used explicitly (@code{catch} and @code{throw})
or implicitly (errors).

@menu
* Catch and Throw::             Programmed non-local exits
* Function Exits::              Returning values from a function
* Cleanup Forms::               Forms which will always be evaluated
* Errors::                      Signalling that an error occurred
@end menu

@node Catch and Throw, Function Exits, , Non-Local Exits
@subsubsection Catch and Throw
@cindex Catch and throw
@cindex Non-local exits, catch and throw

The @code{catch} and @code{throw} structures are used to perform
explicit transfers of control. First a @code{catch} form is used to
setup a @dfn{tag}, this acts like a label for the C language's @code{goto}
statement. To transfer control a @code{throw} form is then used to
transfer to the named tag. The tag is destroyed and the @code{catch}
form exits with the value provided by the @code{throw}.

In a program this looks like,

@lisp
(catch '@var{tag}
  ;; Forms which may `throw' back to @var{tag}
  @dots{}
  (throw '@var{tag} @var{value})
  ;; Control has now passed to the `catch',
  ;; no more forms in this progn will be evaluated.
  @dots{})
    @result{} @var{value}
@end lisp

@noindent
where @var{tag} is the tag to be used (this is normally a symbol) and
@var{value} is the result of the @code{catch} form.

When a throw actually happens all catches in scope are searched for
one with a tag which is @code{eq} to the tag in the throw. If more than
one exists the most-recent is chosen. Now that the catch has been located
the environment is `wound-back' to the catch's position (i.e. local variables
are unbound, cleanup forms removed, unused catches forgotten, etc@dots{})
and all Lisp constructs between the current point of control and
the catch are exited.

For example,

@lisp
(let
    ((test 'outer))
  (cons (catch 'foo
          (let
              ((test 'inner))
            (throw 'foo test)
            (setq test 'unreachable)))  ;Never reached
        test))
    @result{} (inner . outer)
@end lisp

@noindent
when the throw executes the second binding of @code{test} is unwound and
the first binding comes back into effect. For more details on variable
binding see @ref{Local Variables}.

Note that catch tags are @emph{dynamically} scoped, the thrower does not
have to be within the same lexical scope (this means you can throw through
functions).

@defspec catch tag body-forms@dots{}
This special form defines a catch tag which will be accessible while the
@var{body-forms} are being evaluated.

@var{tag} is evaluated and recorded as the tag for this catch. Next the
@var{body-forms} are evaluated as an implicit progn. The value of the
@code{catch} form is either the value of the progn, or, if a @code{throw}
happened, the value specified in the @var{throw} form.

Before exiting the tag installed by this form is removed.
@end defspec

@defun throw tag &optional catch-value
This function transfers the point of control to the catch form with a
tag which is @code{eq} to @var{tag}. The value returned by this catch
form is either @var{catch-value} or @code{nil} if @var{catch-value} is
undefined.

If there is no catch with a tag of @var{tag} an error is signalled and
the editor returns to the top-level of evaluation.
@end defun

@node Function Exits, Cleanup Forms, Catch and Throw, Non-Local Exits
@subsubsection Function Exits
@cindex Function exits
@cindex Non-local exits, function exits

It is often useful to be able to immediately return control from a function
definition (like the C @code{return} statement). Jade's version of Lisp has
the @code{return} function for this.

@defun return &optional value
This function transfers control out of the most-recent lambda-expression
(i.e. a function or macro definition) so that the result of the lambda-
expression is @var{value}.

@lisp
(funcall '(lambda () (return 'x) 'y))
    @result{} x
@end lisp

The @code{'y} form is never evaluated since control is passed straight from
the @code{(return 'y)} form back to the @code{funcall} form.
@end defun

@node Cleanup Forms, Errors, Function Exits, Non-Local Exits
@subsubsection Cleanup Forms
@cindex Cleanup forms
@cindex Non-local exits, cleanup forms

It is sometimes necessary to be sure that a certain form is @emph{always}
evaluated, even when a non-local exit would normally bypass that form.
The @code{unwind-protect} special form is used to stop this happening.

@defspec unwind-protect body-form cleanup-forms@dots{}
The @var{body-form} is evaluated, if it exits normally the @var{cleanup-forms}
are evaluated sequentially then the value which the @var{body-form}
returned becomes the value of the @code{unwind-protect} form. If the
@var{body-form} exits abnormally though (i.e. a non-local exit happened)
the @var{cleanup-forms} are evaluated anyway and the non-local exit
continues.

One use of this is to ensure that an opened file is always closed, for
example,

@lisp
(catch 'foo
  (unwind-protect
      (let
          ((temporary-file (open (tmp-file-name) "w")))
        ;; Use @code{temporary-file}
        (write temporary-file "A test\n")
        ;; Now force a non-local exit
        (throw 'foo))
    ;; This is the @var{cleanup-form} it will @emph{always}
    ;; be evaluated no matter what happens.
    (close temporary-file)))
    @result{} nil
@end lisp
@end defspec

@node Errors, , Cleanup Forms, Non-Local Exits
@subsubsection Errors
@cindex Errors
@cindex Non-local exits, errors

Errors are a type of non-local exit; when a form can not be evaluated
properly an error is normally @dfn{signalled}. If an error-handler has
been installed for that type of error control is unwound back to the
handler and evaluation continues. If there is no suitable handler
control is passed back to the event loop of the most-recent recursive
edit and a suitable error message is printed.

@defun signal error-symbol data
Signals that an error has happened. @var{error-symbol} is a symbol
classifying the type of error, it should have a property @code{error-message}
(a string) which is the error message to be printed.

@var{data} is a list of objects which are relevant to the error --- they will
be made available to any error-handler or printed with the error message
otherwise.

@lisp
(signal 'void-value '(some-symbol))
    @error{} Value as variable is void: some-symbol
@end lisp
@end defun

@defvar debug-on-error
This variable is consulted by the function @code{signal}. If its value
is either @code{t} or a list containing the @var{error-symbol} to
@code{signal} as one of its elements, the Lisp debugger is entered.
When the debugger exits the error is signalled as normal.
@end defvar

When you expect an error to occur and need to be able to regain control
afterwards the @code{error-protect} form can be used.

XXX @code{error-protect} has been replaced by @code{condition-case}

@defspec error-protect body-form error-handlers@dots{}
@code{error-protect} evaluates the @var{body-form} with error
handlers in place.

Each of the @var{error-handlers} is a list whose car is a symbol
defining the type of error which this handler catches. The cdr of
the list is a list of forms to be evaluated sequentially when the
handler is invoked.

While the forms of the error handler are being evaluated the variable
@code{error-info} is bound to the value @code{(@var{error-symbol} . @var{data})}
(these were the arguments to the @code{signal} form which caused the
error).

The special value, the symbol @code{error}, in the car of one of the
@var{error-handlers} will catch @emph{all} types of errors.

@lisp
(error-protect
    (signal 'file-error '("File not found" "/tmp/foo"))
  (file-error
   error-info)
  (error
   (setq x z)))         ;Default handler
    @result{} (file-error "File not found" "/tmp/foo")
@end lisp
@end defspec

@node Variables, Functions, Control Structures, The language
@section Variables
@cindex Variables

In Lisp symbols are used to represent variables. Each symbol contains a
slot which is used to contain the value of the symbol when it is used
as a symbol.

The normal way to obtain the current value of a variable is simply to
evaluate the symbol it lives in (i.e. write the name of the variable
in your program).

@defun symbol-value variable
This function returns the value of the symbol @var{variable} in
the current environment.
@end defun

@menu
* Local Variables::             Creating temporary variables
* Setting Variables::           Altering a variable's value
* Scope and Extent::            Technical jargon
* Void Variables::              Some variables have no values
* Constant Variables::          Variables which may not be altered
* Defining Variables::          How to define a variable before
                                  using it
@end menu

@node Local Variables, Setting Variables, , Variables
@subsection Local Variables
@cindex Local variables
@cindex Variables, local

A @dfn{local variable} is a variable which has a temporary value
while a program is executing, for example, when a function is called
the variables which are the names of its arguments are temporarily
bound (a @dfn{binding} is a particular instance of a local variable)
to the values of the arguments passed to the function. When the function
call exits its arguments are unbound and the previous definitions of
the variables come back into view.

Even if a variable has more than one binding still `active' only the
most recent is visible --- there is absolutely no way the previous
bindings can be accessed until the bindings are unbound one-by-one.

A nice way of visualising variable binding is to think of each variable
as a stack. When the variable is bound to, a new value is pushed onto
the stack, when it is unbound the top of the stack is popped. Similarly
when the stack is empty the value of the variable is void
(@pxref{Void Variables}). Assigning a value to the variable
(@pxref{Setting Variables}) overwrites the top value on the stack with
a new value. When the value of the variable is required it is simply
read from the top of the stack.

Apart from function calls there are two special forms which perform
variable binding (i.e. creating local variables), @code{let} and @code{let*}.

@defspec let bindings body-forms@dots{}
@code{let} creates new variable bindings as specified by the @var{bindings}
argument then evaluates the @var{body-forms} in order. The variables
are then unbound to their state before this @code{let} form and the
value of the implicit progn of the @var{body-forms} becomes the value
of the @code{let} form.

The @var{bindings} argument is a list of the bindings to perform. Each
binding is either a symbol, in which case that variable is bound to
nil, or a list whose car is a symbol. The cdr of this list is a list
of forms which, when evaluated, give the value to bind the variable to.

@lisp
(setq foo 42)
    @result{} 42
(let
    ((foo (+ 1 2))
     bar)
  ;; Body forms
  (setq foo (1+ foo))   ;This sets the new binding
  (cons foo bar))
    @result{} (4 . nil)
foo
    @result{} 42        ;The original values is back
@end lisp

Note that no variables are bound until all the new values have been
computed (unlike in @code{let*}). For example,

@lisp
(setq foo 42)
    @result{} 42
(let
    ((foo 100)
     (bar foo))
  (cons foo bar))
    @result{} (100 . 42)
@end lisp

@noindent
Although @code{foo} is given a new binding this is not actually done
until all the new bindings have been computed, hence @code{bar} is bound to
the @emph{old} value of @code{foo}.
@end defspec

@defspec let* bindings body-forms@dots{}
This special form is exactly the same as @code{let} except for one
important difference: the new bindings are installed @emph{as they are
computed}.

You can see the difference by comparing the following example with the
last example in the @code{let} documentation (above),

@lisp
(setq foo 42)
    @result{} 42
(let*                   ;Using @code{let*} this time
    ((foo 100)
     (bar foo))
  (cons foo bar))
    @result{} (100 . 100)
@end lisp

@noindent
By the time the binding of @code{bar} is computed the new binding of
@code{foo} has already been installed.
@end defspec

@node Setting Variables, Scope and Extent, Local Variables, Variables
@subsection Setting Variables
@cindex Setting variables
@cindex Variables, setting

@dfn{Setting} a variable means to overwrite its current value (that is, the
value of its most recent binding) with a new one. The old value is
irretrievably lost (unlike when a new value is bound to a variable,
@pxref{Local Variables}).

@defspec setq variable form @dots{}
The special form @code{setq} is the usual method of altering the value of
a variable. Each @var{variable} is set to the result of evaluating its
corresponding @var{form}. The last value assigned becomes the value of
the @code{setq} form.

@lisp
(setq x 20 y (+ 2 3))
    @result{} 5
@end lisp

@noindent
In the above example the variable @code{x} is set to @code{20} and @code{y}
is set to the value of the form @code{(+ 2 3)} (5).
@end defspec

@defun set variable new-value
The value of the variable @var{variable} (a symbol) is set to @var{new-value}
and the @var{new-value} is returned.

This function is used when the @var{variable} is unknown until run-time, and
therefore has to be computed from a form.

@lisp
(set 'foo 20)
@equiv{}
(setq foo 20)           ;@code{setq} means `set-quoted'
    @result{} 20
@end lisp
@end defun

@node Scope and Extent, Void Variables, Setting Variables, Variables
@subsection Scope and Extent
@cindex Scope and extent
@cindex Variables, scope and extent of

In Jade's version of Lisp all variables have @dfn{indefinite scope} and
@dfn{dynamic extent}. What this means is that references to variables
may occur anywhere in a program (i.e. bindings established in one
function are not only accessible within that function, that's lexical
scope) and that references may occur at any point in the time between
the binding being created and it being unbound.

The combination of indefinite scope and dynamic extent is often
termed @dfn{dynamic scope}.

As an aside, Lisp objects have @dfn{indefinite extent}, meaning that
the object will exist for as long as there is a possibility of it
being referenced (and possibly longer --- until the garbage collector
runs).

Note that in Common Lisp only those variables declared `special' have
indefinite scope and dynamic extent.

Try not to abuse the dynamic scoping, although it is often very useful
to be able to bind a variable in one function and use it in another
this can be confusing if not controlled and documented properly.

A quick example of the use of dynamic scope,

@lisp
(defun foo (x)
  (let
      ((foo-var (* x 20)))
    (bar x)
    @dots{}

(defun bar (y)
  ;; Since this function is called from
  ;; the function @code{foo} it can refer
  ;; to any bindings which @code{foo} can.
  (setq y (+ y foo-var))
  @dots{}
@end lisp

@node Void Variables, Constant Variables, Scope and Extent, Variables
@subsection Void Variables
@cindex Void variables
@cindex Variables, void

A variable which has no value is said to be @dfn{void}, attempting to
reference the value of such a symbol will result in an error. It is
possible for the most recent binding of a variable to be void even though
the inactive bindings may have values.

@defun boundp variable
Returns @code{t} if the symbol @var{variable} has a value, @code{nil} if
its value is void.
@end defun

@defun makunbound variable
This function makes the current binding of the symbol @var{variable} be
void, then returns @var{variable}.

@lisp
(setq foo 42)
    @result{} 42
foo
    @result{} 42
(boundp 'foo)
    @result{} t
(makunbound 'foo)
    @result{} foo
(boundp 'foo)
    @result{} nil
foo
    @error{} Value as variable is void: foo
@end lisp
@end defun

@node Constant Variables, Defining Variables, Void Variables, Variables
@subsection Constant Variables
@cindex Constant variables
@cindex Variables, constant

In Lisp constants are represented by variables which have been marked as
being read-only. Any attempt to alter the value of a constant results
in an error.

Two of the most commonly used constants are @code{nil} and @code{t}.

@defun set-const-variable variable &optional read-write
This function defines whether or not the value of the symbol @var{variable}
may be modified. If @var{read-write} is @code{nil} or undefined the variable
is marked to be constant, otherwise it's marked to be a normal variable.
The value returned is @var{variable}.
@end defun

@defun const-variable-p variable
Returns @code{t} if the value of the symbol @var{variable} may be altered,
@code{nil} otherwise.
@end defun

Constants may behave a bit strangely when you compile the program they
are used in: the value of the constant is likely to be hardwired into
the compiled functions it is used in, and the constant is unlikely to
be @code{eq} to itself!

The compiler assumes that constant is always the same, whenever it is
evaluated. It may even be evaluated more than once. @xref{Compiled Lisp}.

The special form @code{defconst} can be used to define constants,
see @ref{Defining Variables}.

@node Defining Variables, , Constant Variables, Variables
@subsection Defining Variables
@cindex Defining variables
@cindex Variables, defining

The special forms @code{defvar} and @code{defconst} allow you to define
the global variables which will be used in a program. This is entirely
optional; it is highly recommended though.

@defspec defvar variable form [doc-string]
This special form defines a global variable, the symbol @var{variable}. If
the value of @var{variable} is void the @var{form} is evaluated and its
value is stored as the value of @var{variable} (note that the default
value is modified, never a buffer-local value).

If the @var{doc-string} argument is defined it is a string documenting
@var{variable}. This string is then stored as the symbol's
@code{variable-documentation} property and can be accessed by the
@code{describe-variable} function.

@lisp
(defvar my-variable '(x y)
  "This variable is an example showing the usage of the @code{defvar}
special form.")
    @result{} my-variable
@end lisp
@end defspec

@defspec defconst constant form [doc-string]
@code{defconst} defines a constant, the symbol @var{constant}. Its value
(in the case of a buffer-local symbol, its default value) is set to the
result of evaluating @var{form}. Note that unlike @code{defvar} the value
of the symbol is @emph{always} set, even if it already has a value.

The @var{doc-string} argument, if defined, is the documentation string
for the constant.

@lisp
(defconst the-answer 42
  "An example constant.")
    @result{} the-answer
@end lisp

@xref{Constant Variables}.
@end defspec

@node Functions, Macros, Variables, The language
@section Functions
@cindex Functions

A @dfn{function} is a Lisp object which, when applied to a sequence of
argument values, produces a value --- the function's @dfn{result}. It
may also produce side-effects. All Lisp functions return results --- there
is nothing like a procedure in Pascal.

Functions are the main building-block in Lisp programs, each program is
usually a system of inter-related functions.

There are two types of function: @dfn{primitive functions} are functions
written in the C language, these are sometimes called built-in functions,
the object containing the C code itself is called a @dfn{subr}. All other
functions are written in Lisp.

@defun functionp object
Returns @code{t} if @var{object} is a function (i.e. it can be used
as the function argument of @code{funcall}.

@lisp
(functionp 'set)
    @result{} t

(functionp 'setq)
    @result{} nil

(functionp #'(lambda (x) (+ x 2)))
   @result{} t
@end lisp
@end defun

@menu
* Lambda Expressions::          Structure of a function object
* Named Functions::             Functions can be named by symbols,
* Anonymous Functions::         Or they can be un-named
* Predicate Functions::         Functions which return boolean values
* Defining Functions::          How to write a function definition
* Calling Functions::           Functions can be called by hand
* Mapping Functions::           Map a function to the elements of a list
@end menu

@node Lambda Expressions, Named Functions, , Functions
@subsection Lambda Expressions
@cindex Lambda expressions
@cindex Functions, lambda expressions

@dfn{Lambda expressions} are used to create an object of type function
from other Lisp objects, it is a list whose first element is the
symbol @code{lambda}. All functions written in Lisp (as opposed to the
primitive functions in C) are represented by a lambda expression.

Note that a lambda expression is @emph{not} an expression, evaluating a
lambda expression will give an error (unless there is a function called
@code{lambda}).

The format of a lambda expression is:

@lisp
(lambda @var{lambda-list} [@var{doc}] [@var{interactive-declaration}] @var{body-forms}@dots{} )
@end lisp

@noindent
Where @var{lambda-list} is the argument specification of the function,
@var{doc} is an optional documentation string, @var{interactive-declaration}
is only required by editor commands (@pxref{Commands}) and the
@var{body-forms} is the actual function code (when the function is called
each form is evaluated in sequence, the last form's value is the result
returned by the function).

The @var{lambda-list} is a list, it defines how the argument values
applied to the function are bound to local variables which represent
the arguments within the function. At its simplest it is simply a
list of symbols, each symbol will have the corresponding argument
value bound to it. For example, the lambda list,

@lisp
(lambda (x y) (+ x y))
@end lisp

@noindent
takes two arguments, @code{x} and @code{y}. When this function is called
with two arguments the first will be bound to @code{x} and the second
to @code{y} (then the function will return their sum).

To complicate matters there are several @dfn{lambda-list keywords} which
modify the meaning of symbols in the lambda-list. Each keyword is
a symbol whose name begins with an ampersand, they are:

@table @code
@item &optional
All the variables following this keyword are considered @dfn{optional} (all
variables before the first keyword are @dfn{required}: an error will be
signalled if a required argument is undefined in a function call). If
an optional argument is undefined it will simply be given the value @code{nil}.

Note that optional arguments must be specified if a later optional argument
is also specified. Use @code{nil} to explicitly show that an optional
argument is undefined.

For example, if a function @code{foo} takes two optional arguments and
you want to call it with only the second argument defined, the first
argument must be specified as @code{nil} to ensure that the correct argument
value is bound to the correct variable.

@lisp
(defun foo (&optional arg-1 arg-2)
  @dots{}

(foo nil arg-2-value)   ;Leave the first argument undefined
@end lisp

@item &rest
The @code{&rest} keyword allows a variable number of arguments to be
applied to a function, all the argument values which have not been
bound to argument variables are simply consed into a list and bound
to the variable after the @code{&rest} keyword. For example, in,

@lisp
(lambda (x &rest y) @dots{})
@end lisp

@noindent
the first argument, @code{x}, is required. Any other arguments applied
to this function are made into a list and this list is bound to the
@code{y} variable.
@end table

When a function represented by a lambda-list is called the first thing that
happens is to bind the argument values to the argument variables. The
@var{lambda-list} and the list of argument values applied to the
function are worked through in parallel. Any required arguments which are
left undefined when the end of the argument values has been reached
causes an error.

After the arguments have been processed the @var{body-forms} are evaluated
by an implicit progn, the value of which becomes the value of the function
call. Finally, all argument variables are unbound and control passes
back to the caller.

@node Named Functions, Anonymous Functions, Lambda Expressions, Functions
@subsection Named Functions
@cindex Named functions
@cindex Functions, named

Functions are normally associated with symbols, the name of the symbol
being the same as the name of its associated function. Each symbol
has a special function cell (this is totally separate from the symbol's
value as a variable --- variables and functions may have the same name
without any problems occurring) which is used to store the function's
definition, either a lambda expression (@pxref{Lambda Expressions}) or
a subr (C code) object.

The evaluator knows to indirect through the function value of a symbol
in any function call (@pxref{Function Call Forms}) so the normal way
to call a function is simply write its name as the first element in
a list, any arguments making up the other elements in the list.
@xref{List Forms}.

The functions and special forms which take functions as their arguments
(i.e. @code{funcall}) can also take symbols. For example,

@lisp
(funcall 'message "An example")
@equiv{}
(message "An example")
@end lisp

@defun symbol-function symbol
Returns the value of the function cell in the symbol @var{symbol}.

@lisp
(symbol-function 'symbol-function)
    @result{} #<subr symbol-function>
@end lisp
@end defun

@defun fboundp symbol
This function returns @code{t} if the symbol @var{symbol} has a
non-void value in its function cell, @code{nil} otherwise.

@lisp
(fboundp 'setq)
    @result{} t
@end lisp
@end defun

@defun fset symbol new-value
Sets the value of the function cell in the symbol @var{symbol} to
@var{new-value}, then returns @var{new-value}.

This function is rarely used, see @ref{Defining Functions}.
@end defun

@defun fmakunbound symbol
This function makes the value of the function cell in @var{symbol} void,
then returns @var{symbol}.
@end defun

@node Anonymous Functions, Predicate Functions, Named Functions, Functions
@subsection Anonymous Functions
@cindex Anonymous functions
@cindex Functions, anonymous

When giving function names as arguments to functions it is useful to
give an actual function @emph{definition} (i.e. a lambda expression)
instead of the name of a function.

In Lisp, unlike most other programming languages, functions have no
inherent name. As seen in the last section named-functions are created
by storing a function in a special slot of a symbol, if you want, a
function can have many different names: simply store the function in
many different symbols!

So, when you want to pass a function as an argument there is the option
of just writing down its definition. This is especially useful with
functions like @code{mapcar} and @code{delete-if}. For example, the
following form removes all elements from the @var{list} which are
even and greater than 20.

@lisp
(setq @var{list} (delete-if #'(lambda (x)
                                (and (zerop (% x 2))
                                     (> x 20)))
                            @var{list}))
@end lisp

The lambda expression is very simple, it combines two predicates applied
to its argument.

Note that the function definition is quoted by @code{#'}, not the
normal @code{'}. This is a special shortcut for the @code{function} special
form (like @code{'} is a shortcut to @code{quote}). In general,
@code{#'@var{x}} is expanded by the Lisp reader to @code{(function @var{x})}.

@defspec function arg
This special form is nearly identical to the @code{quote} form, it
always returns its argument without evaluating it. The difference is
that the Lisp compiler knows to compile the @var{arg} into a byte-code
form (unless @var{arg} is a symbol in which case it is not compiled).

What this means is when you have to quote a function, use the @code{#'}
syntax.
@end defspec

@node Predicate Functions, Defining Functions, Anonymous Functions, Functions
@subsection Predicate Functions
@cindex Predicate functions
@cindex Boolean values, predicate functions

In Lisp, a function which returns a boolean `true' or boolean `false'
value is called a @dfn{predicate}. As is the convention in Lisp a
value of @code{nil} means false, anything else means true. The symbol
@code{t} is often used to represent a true value (in fact, sometimes
the symbol @code{t} should be read as @emph{any} non-@code{nil} value).

Another Lisp convention is that the names of predicate functions should
be the concept the predicate is testing for and either @samp{p} or @samp{-p}.

The @samp{p} variant is used when the concept name does not contain
any hyphens.

For example a predicate to test for the concept @dfn{const-variable} (a
variable which has a constant value, @pxref{Constant Variables}) would
be called @code{const-variable-p}. On the other hand a predicate
to test for the concept @dfn{buffer} (a Lisp object which is a buffer)
would be called @code{bufferp}.

@node Defining Functions, Calling Functions, Predicate Functions, Functions
@subsection Defining Functions
@cindex Defining functions
@cindex Functions, defining

Named functions are normally defined by the @code{defun} special form.

@defspec defun name lambda-list body-forms@dots{}
@code{defun} initialises the function definition of the symbol @var{name}
to the lambda expression resulting from the concatenation of the
symbol @code{lambda}, @var{lambda-list} and the @var{body-forms}. So,

@lisp
(defun foo (x y)
  @dots{}
@equiv{}
(fset 'foo #'(lambda (x y)
               @dots{}
@end lisp

The @var{body-forms} may contain a documentation string for the function
as its first form and an interactive calling specification as its first (if
there is no doc-string) or second form if the function may be called
interactively by the user (@pxref{Commands}).
@end defspec

An example function definition (actually a command) taken from Jade's
source is,

@lisp
(defun upcase-word (count)
  "Makes the next COUNT words from the cursor upper-case."
  (interactive "p")
  (let
      ((pos (forward-word count)))
    (upcase-area (cursor-pos) pos)
    (goto-char pos)))
@end lisp

@node Calling Functions, Mapping Functions, Defining Functions, Functions
@subsection Calling Functions
@cindex Calling functions
@cindex Functions, calling

Most of the time function calls are done by the evaluator when it detects
a function call form (@pxref{List Forms}); when the function to be called
is not known until run-time it is easier to use a special function to
call the function directly than create a custom form to apply to the
@code{eval} function.

@defun funcall function &rest args
Applies the argument values @var{args} to the function @var{function}, then
returns its result.

Note that the argument values @var{args} are @emph{not} evaluated again. This
also means that @code{funcall} can @emph{not} be used to call macros
or special forms --- they would need the unevaluated versions of @var{args},
which are not available to @code{funcall}.

@lisp
(funcall '+ 1 2 3)
    @result{} 6
@end lisp
@end defun

@defun apply function &rest args
Similar to @code{funcall} except that the last of its arguments is
a @emph{list} of arguments which are appended to the other members of
@var{args} to form the list of argument values to apply to the
function @var{function}.

Constructs a list of arguments to apply to the function @var{function}
from @var{args}.
@end defun

@node Mapping Functions, , Calling Functions, Functions
@subsection Mapping Functions
@cindex Mapping functions
@cindex Functions, mapping
@cindex Lists, mapping

A @dfn{mapping function} applies a function to each of a collection of
objects. Jade currently has two mapping functions, @code{mapcar} and
@code{mapc}.

@defun mapcar function list
Each element in the list @var{list} is individually applied to the
function @var{function}. The values returned are made into a new
list which is returned.

The @var{function} should be able to be called with one argument.

@lisp
(mapcar '1+ '(1 2 3 4 5))
    @result{} (2 3 4 5 6)
@end lisp
@end defun

@defun mapc function list
Similar to @code{mapcar} except that the values returned when each element
is applied to the function @var{function} are discarded. The value returned
is @var{list}.

This function is generally used where the side effects of calling the
function are the important thing, not the results.
@end defun

The two following functions are also mapping functions of a sort. They
are variants of the @code{delete} function (@pxref{Modifying Lists})
and use predicate functions to classify the elements of the list
which are to be deleted.

@defun delete-if predicate list
This function is a variant of the @code{delete} function. Instead of
comparing each element of @var{list} with a specified object, each
element of @var{list} is applied to the predicate function @var{predicate}.
If it returns @code{t} (i.e. not @code{nil}) then the element is destructively
removed from @var{list}.

@lisp
(delete-if 'stringp '(1 "foo" 2 "bar" 3 "baz"))
    @result{} (1 2 3)
@end lisp
@end defun

@defun delete-if-not predicate list
This function does the inverse of @code{delete-if}. It applies @var{predicate}
to each element of @var{list}, if it returns @code{nil} then the element
is destructively removed from the list.

@lisp
(delete-if-not 'stringp '(1 "foo" 2 "bar" 3 "baz"))
    @result{} ("foo" "bar" "baz")
@end lisp
@end defun

@node Macros, Streams, Functions, The language
@section Macros
@cindex Macros

@dfn{Macros} are used to extend the Lisp language, they are basically
a function which instead of returning its value, return a new form
which will produce the macro call's value when evaluated.

When a function being compiled calls a macro the macro is expanded
immediately and the resultant form is open-coded into the compiler's
output.

@menu
* Defining Macros::             Macros are defined like functions
* Macro Expansion::             How macros are used by the evaluator
* Compiling Macros::            The compiler expands macros at compile-
                                  time.
@end menu

@node Defining Macros, Macro Expansion, , Macros
@subsection Defining Macros
@cindex Defining macros
@cindex Macros, defining

Macros are defined in the same style as functions, the only difference
is the name of the special form used to define them.

A macro object is a list whose car is the symbol @code{macro}, its
cdr is the function which creates the expansion of the macro when
applied to the macro calls unevaluated arguments.

@defspec defmacro name lambda-list body-forms@dots{}
Defines the macro stored in the function cell of the symbol @var{name}.
@var{lambda-list} is the lambda-list specifying the arguments to the
macro (@pxref{Lambda Expressions}) and @var{body-forms} are the forms
evaluated when the macro is expanded. The first of @var{body-forms}
may be a documentation string describing the macro's use.
@end defspec

Here is a simple macro definition, it is a possible definition for
the @code{when} construct (which might even be useful if @code{when} wasn't
already defined as a special form@dots{}),

@lisp
(defmacro when (condition &rest body)
  "Evaluates @var{condition}, if it's non-@code{nil} evaluates the @var{body}
forms."
  (list 'if condition (cons 'progn body)))
@end lisp

@noindent
When a form of the type @code{(when @var{c} @var{b} @dots{})} is evaluated
the macro definition of @code{when} expands to the form
@code{(if @var{c} (progn @var{b} @dots{}))} which is then evaluated to
perform my when-construct.

When you define a macro ensure that the forms which produce the expansion
have no side effects; it would fail spectacularly when you attempt to
compile your program!

@node Macro Expansion, Compiling Macros, Defining Macros, Macros
@subsection Macro Expansion
@cindex Macro expansion

When a macro call is detected (@pxref{List Forms}) the function which
is the cdr of the macro's definition (@pxref{Defining Macros}) is applied
to the macro call's arguments. Unlike in a function call, the arguments
are @emph{not evaluated}, the actual forms are the arguments to the
macro's expansion function. This is so these forms can be rearranged by
the macro's expansion function to create the new form which will be evaluated.

There is a function which performs macro expansion, its main use is to
let the Lisp compiler expand macro calls at compile time.

@defun macroexpand form &optional environment
If @var{form} is a macro call @code{macroexpand} will expand that call
by calling the macro's expansion function (the cdr of the macro definition).
If this expansion is another macro call the process is repeated until
an expansion is obtained which is not a macro call, this form is
then returned.

The optional @var{environment} argument is an alist of macro
definitions to use as well as the existing macros; this is mainly used
for compiling purposes.

@lisp
(defmacro when (condition &rest body)
  "Evaluates @var{condition}, if it's non-@code{nil} evaluates the @var{body}
forms."
  (list 'if condition (cons 'progn body)))
    @result{} when

(macroexpand '(when x (setq foo bar)))
    @result{} (if x (progn (setq foo bar)))
@end lisp
@end defun

@node Compiling Macros, , Macro Expansion, Macros
@subsection Compiling Macros
@cindex Compiling macros
@cindex Macros, compiling

Although it may seem odd that macros return a form to produce a result
and not simply the result this is their most important feature. It
allows the expansion and the evaluation of the expansion to happen
at different times.

The Lisp compiler makes use of this; when it comes across a macro call
in a form it is compiling it uses the @code{macroexpand} function to
produce the expansion of that form which it then compiles straight into
the object code. Obviously this is good for performance (why evaluate the
expansion every time it is needed when once will do?).

Some rules do need to be observed to make this work properly:

@itemize @bullet
@item
When the compiler compiles a file it remembers the macros which have been
defined by that file; it can only expand a macro call if the definition
of the macro appears before the macro call itself (it can't read your mind).

@item
The macro expansion function (i.e. the definition of the macro) should
not have any side effects or evaluate its arguments (the value of a symbol
at compile-time probably won't be the same as its value at run-time).

@item
Macros which are defined by another file must be loaded so they can be
recognised. Use the @code{require} function, the compiler will evaluate
any top-level @code{require} forms it sees to bring in any macro
definitions used.
@end itemize

@node Streams, Loading, Macros, The language
@section Streams
@cindex Streams
@cindex Input and output

A @dfn{stream} is a Lisp object which is either a data sink (an
@dfn{output stream}) or a data source (an @dfn{input stream}). In
Jade all streams produce or consume sequences of 8-bit characters.

Streams are very flexible, functions using streams for their input
and output do not need to know what type of stream it is. For example
the Lisp reader (the @code{read} function) takes an input stream as its
one argument, it then reads characters from this stream until it has
parsed a whole object. This stream could be a file, a position in a
buffer, a function or even a string; the @code{read} function can not
tell the difference.

@defun streamp object
This function returns @code{t} if its argument is a stream.
@end defun

@menu
* Input Streams::               Types of input stream
* Output Streams::              Types of output stream
* Input Functions::             Functions to read from streams
* Output Functions::            How to output to a stream
@end menu

@node Input Streams, Output Streams, , Streams
@subsection Input Streams
@cindex Input streams
@cindex Streams, input

These are the possible types of input stream, for the functions which
use them see @ref{Input Functions}.

@table @code
@item @var{file}
Characters are read from the file object @var{file}, for the functions
which manipulate file objects see @ref{Files}.

@item @var{function}
Each time an input character is required the @var{function} is called with
no arguments. It should return the character read (an integer) or @code{nil}
if for some reason no character is available.

@var{function} should also be able to `unread' one character. When this
happens the function will be called with one argument --- the value of
the last character read. The function should arrange it so that the
next time it is called it returns this character. A possible implementation
could be,

@lisp
(defvar ms-unread-char nil
  "If non-nil the character which was pushed back.")

(defun my-stream (&optional unread-char)
  (if unread-char
      (setq ms-unread-char unread-char)
    (if ms-unread-char
        (prog1
          ms-unread-char
          (setq ms-unread-char nil))
      ;; Normal case -- read and return a character from somewhere
      @dots{}
@end lisp

@item nil
Read from the stream stored in the variable @code{standard-input}.
@end table

It is also possible to use a string as an input stream. The string to
be read from must be applied to the @code{make-string-input-stream} function
and the result from this function used as the input stream.

@defun make-string-input-stream string &optional start
Returns an input stream which will supply the characters of the string
@var{string} in order starting with the character at position @var{start}
(or from position zero if this argument is undefined).

@lisp
(read (make-string-input-stream "(1 . 2)"))
    @result{} (1 . 2)
@end lisp
@end defun

@defvar standard-input
The input stream which is used when no other is specified or is @code{nil}.
@end defvar

@node Output Streams, Input Functions, Input Streams, Streams
@subsection Output Streams
@cindex Output streams
@cindex Streams, output

These are the different types of output stream, for the functions which
use them see @ref{Output Functions}.

@table @code
@item @var{file}
Writes to the file object @var{file}. @xref{Files}.

@item @var{function}
The function @var{function} is called with one argument, either a string
or a character. This should be used as the circumstances dictate. If the
function returns a number it is the number of characters actually used,
otherwise it is assumed that all the characters were successful.

@item @var{process}
Writes to the standard input of the process object @var{process}. If
@var{process} isn't running an error is signalled. @xref{Processes}. 

@item t
Appends the character(s) to the end of the status line message.

@item nil
Write to the stream stored in the variable @code{standard-output}.
@end table

It is also possible to store the characters sent to an output stream
in a string.

@defun make-string-output-stream
Returns an output stream. It accumulates the text sent to it for the benefit
of the @code{get-output-stream-string} function.
@end defun

@defun get-output-stream-string string-output-stream
Returns a string consisting of the text sent to the @var{string-output-stream}
since the last call to @var{get-output-stream-string} (or since this stream
was created by @code{make-string-output-stream}).

@lisp
(setq stream (make-string-output-stream))
    @result{} ("" . 0)
(prin1 keymap-path stream)
    @result{} ("(lisp-mode-keymap global-keymap)" . 64)
(get-output-stream-string stream)
    @result{} "(lisp-mode-keymap global-keymap)"
@end lisp
@end defun

@defvar standard-output
This variable contains the output stream which is used when no other
is specified (or when the given output stream is @code{nil}).
@end defvar

@node Input Functions, Output Functions, Output Streams, Streams
@subsection Input Functions
@cindex Input functions
@cindex Functions, input

@defun read-char stream
Read and return the next character from the input stream @var{stream}. If
the end of the stream is reached @code{nil} is returned.
@end defun

@defun read-line stream
This function reads one line of characters from the input stream @var{stream},
creates a string containing the line (including the newline character
which terminates the line) and returns it.

If the end of stream is reached before any characters can be read @code{nil}
is returned, if the end of stream is reached but some characters have
been read (but not the newline) these characters are made into a string
and returned.

Note that unlike the Common Lisp function of the same name, the newline
character is not removed from the returned string.
@end defun

@defun read stream
This function is the function which contains the Lisp reader
(@pxref{The Lisp Reader}). It reads as many characters from the input
stream @var{stream} as it needs to make the read syntax of a single
Lisp object (@pxref{Read Syntax}), this object is then returned.
@end defun

@defun read-from-string string &optional start
Reads one Lisp object from the string @var{string}, the first character
is read from position @var{start} (or position zero).

@lisp
(read-from-string @var{string} @var{start})
@equiv{}
(read (make-string-input-stream @var{string} @var{start}))
@end lisp
@end defun

@node Output Functions, , Input Functions, Streams
@subsection Output Functions
@cindex Output functions
@cindex Functions, output

@defun write stream data &optional length
Writes the specified character(s) to the output stream @var{stream}.
@var{data} is either the character or the string to be written. If
@var{data} is a string the optional argument @var{length} may
specify how many characters are to be written. The value returned
is the number of characters successfully written.

@lisp
(write standard-output "Testing 1.. 2.. 3..")
    @print{} Testing 1.. 2.. 3..
    @result{} 19
@end lisp
@end defun

@defun copy-stream input-stream output-stream
This function copies all characters which may be read from @var{input-stream}
to @var{output-stream}. The copying process is not stopped until the
end of the input stream is read. Returns the number of characters copied.

Be warned, if you don't choose the streams carefully you may get a deadlock
which only an interrupt signal can break!
@end defun

@defun print object &optional stream
Outputs a newline character to the output stream @var{stream}, then writes
a textual representation of @var{object} to the stream.

If possible, this representation will be such that @code{read} can
turn it into an object structurally similar to @var{object}. This will
@emph{not} be possible if @var{object} does not have a read syntax.

@var{object} is returned.

@lisp
(print '(1 2 3))
    @print{}
    @print{} (1 2 3)
    @result{} (1 2 3)
@end lisp
@end defun

@defun prin1 object &optional stream
Similar to @code{print} but no initial newline is output.

@lisp
(prin1 '(1 2 3))
    @print{} (1 2 3)
    @result{} (1 2 3)

(prin1 '|(xy((z]|)              ;A strange symbol
    @print{} \(xy\(\(z\]
    @result{} \(xy\(\(z\]
@end lisp
@end defun

@defun prin1-to-string object
Returns a string containing the characters that @code{prin1} would
output when it prints @var{object}.

@lisp
(prin1-to-string '(1 2 3))
    @result{} "(1 2 3)"
@end lisp
@end defun

@defun princ object &optional stream
Prints a textual representation of @var{object} to the output stream
@var{stream}. No steps are taken to create output that @code{read} can
parse and no quote characters surround strings.

@lisp
(princ "foo")
    @print{} foo
    @result{} "foo"

(princ '|(xy((z]|)
    @print{} (xy((z]
    @result{} \(xy\(\(z\]
@end lisp
@end defun

@defun format stream template &rest values
Writes to a stream, @var{stream}, a string constructed from the
format string, @var{template}, and the argument @var{values}.

If @var{stream} is @code{nil} the resulting string will be returned, not
written to a stream.

@var{template} is a string which may contain format specifiers, these are
a @samp{%} character followed by another character telling how to print
the next of the @var{values}. The following options are available

@table @samp
@item s
Write the printed representation of the value without quoting (as if from
the @code{princ} function).

@item S
Write the printed representation @emph{with} quoting enabled (like the
@code{prin1} function).

@item d
Output the value as a decimal number.

@item o
Write the value in octal.

@item x
In hexadecimal.

@item c
Write the character specified by the value.

@item %
Print a literal percent character. None of the @var{values} are used.
@end table

The function works through the @var{template} a character at a time. If
the character is a format specifier (a @samp{%}) it inserts the correct
string (as defined above) into the output. Otherwise, the character is
simply put into the output stream.

If @var{stream} isn't @code{nil} (i.e. the formatted string is returned) the
value of @var{stream} is returned.

@lisp
(format nil "foo %S bar 0x%x" '(x . y) 255)
    @result{} "foo (x . y) bar 0xff"

(format standard-output "The %s is %s!" "dog" "purple")
    @print{} The dog is purple!
    @result{} #<buffer *jade*>
@end lisp
@end defun

@node Loading, Compiled Lisp, Streams, The language
@section Loading
@cindex Loading
@cindex Loading programs
@cindex Protrams, loading

In Lisp, programs (also called @dfn{modules}) are stored in files. Each file
is a sequence of Lisp forms (known as @dfn{top-level forms}). Most of the
top-level forms in a program will be definitions (i.e. function, macro or
variable definitions) since generally each module is a system of related
functions and variables.

Before the program can be used it has to be @dfn{loaded} into the editor's
workspace; this involves reading and evaluating each top-level form in
the file.

@menu
* Load Function::               The function which loads programs
* Autoloading::                 Functions can be loaded on reference
* Features::                    Module management functions
@end menu

XXX add description of loading dl objects and @code{dl-load-path}. Also
document the @code{after-load-alist} variable, etc

@node Load Function, Autoloading, , Loading
@subsection Load Function
@cindex Load function
@cindex Functions, loading

@defun load program &optional no-error no-path no-suffix
This function loads the file containing the program called @var{program};
first the file is located then each top-level form contained by the file
is read and evaluated in order.

Each directory named by the variable @code{load-path} is searched until
the file containing @var{program} is found. In each directory three
different file names are tried,

@enumerate
@item
@var{program} with @samp{.jlc} appended to it. Files with a @samp{.jlc}
suffix are usually compiled Lisp files. @xref{Compiled Lisp}.

@item
@var{program} with @samp{.jl} appended, most uncompiled Lisp programs are
stored in files with names like this.

@item
@var{program} with no modifications.
@end enumerate

If none of these gives a result the next directory is searched in the
same way, when all directories in @code{load-path} have been exhausted
and the file still has not been found an error is signalled.

Next the file is opened for reading and Lisp forms are read from it
one at a time, each form is evaluated before the next form is read. When
the end of the file is reached the file has been loaded and this function
returns @code{t}.

The optional arguments to this function are used to modify its behaviour,

@table @var
@item no-error
When this argument is non-@code{nil} no error is signalled if the file
can not be located. Instead the function returns @code{nil}.

@item no-path
The variable @code{load-path} is not used, @var{program} must point to
the file from the current working directory.

@item no-suffix
When non-@code{nil} no @samp{.jlc} or @samp{.jl} suffixes are applied to
the @var{program} argument when locating the file.
@end table

If a version of the program whose name ends in @samp{.jlc} is older than
a @samp{.jl} version of the same file (i.e. the source code is newer than
the compiled version) a warning is displayed and the @samp{.jl} version
is used.

@lisp
(load "foobar")
    @error{} File error: Can't open lisp-file, foobar

(load "foobar" t)
    @result{} nil
@end lisp
@end defun

@defvar load-path
A list of strings, each element is the name of a directory which is
prefixed to the name of a program when Lisp program files are being
searched for.

@lisp
load-path
    @result{} ("" "/usr/local/lib/jade/3.2/lisp/")
@end lisp

The element @code{""} means the current directory, note that directory
names should have an ending @samp{/} (or whatever) so that when concatenated
with the name of the file they make a meaningful filename.
@end defvar

@defvar lisp-lib-dir
The name of the directory in which the standard Lisp files are stored.

@lisp
lisp-lib-dir
    @result{} "/usr/local/lib/jade/3.2/lisp/"
@end lisp
@end defvar

@node Autoloading, Features, Load Function, Loading
@subsection Autoloading
@cindex Autoloading
@cindex Loading, on reference

Obviously, not all the features of the editor are always used. @dfn{Autoloading}
allows modules to be loaded when they are referenced. This speeds up the
initialisation process and may save memory.

Functions which may be autoloaded have a special form in their symbol's
function cell --- an autoload form. This is a list whose first element
is the symbol @code{autoload}. When the function call dispatcher finds
one of these forms it loads the program file specified in the form
then re-evaluates the function call. The true function definition will
have been loaded and therefore the call may proceed as normal.

The structure of an autoload form is:

@lisp
(autoload @var{program-file} [@var{is-command}])
@end lisp

@var{program-file} is the argument to give to the @code{load} function when
the function is to be loaded. It should be the program containing a definition
of the autoloaded function.

The optional @var{is-command} object specifies whether or not the function
may be called interactively (i.e. it is an editor command).

@defun autoload symbol &rest autoload-defn
Installs an autoload form into the function cell of the symbol @var{symbol}.
The form is a cons cell whose car is @code{autoload} and whose cdr is
the argument @var{autoload-defn}.

Returns the resulting autoload form.

@lisp
(autoload 'foo "foos-file")
    @result{} (autoload "foos-file")
(symbol-function 'foo)
    @result{} (autoload "foos-file")

(autoload 'bar "bars-file" t)
    @result{} (autoload "bars-file" t)
(commandp 'bar)
    @result{} t
@end lisp
@end defun

It is not necessary to call the @code{autoload} function manually. Simply
prefix the definitions of all the functions which may be autoloaded (i.e.
the entry points to your module; @emph{not} all the internal functions!)
with the magic comment @code{;;;###autoload}. Then the @code{add-autoloads}
command can be used to create the necessary calls to the autoload function
in the @file{autoloads.jl} Lisp file (this file which lives in the Lisp
library directory is loaded when the editor is initialised).

@table @kbd
@item Meta-x add-autoloads
@kindex Meta-x add-autoloads
Scans the current buffer for any autoload definitions. Functions with
the comment @code{;;;###autoload} preceding them have autoload forms
inserted into the @file{autoloads.jl} file. Simply save this file's
buffer and the new autoloads will be used the next time Jade is
initialised.

It is also possible to mark arbitrary forms for inclusion in the
@file{autoloads.jl} file: put them on a single line which starts with
the comment @code{;;;###autoload} call the command.

The unsaved @file{autoloads.jl} buffer will become the current buffer.

@lisp
;;;###autoload
(defun foo (bar)                ;@code{foo} is to be autoloaded
  @dots{}

;;;###autoload (setq x y)       ;Form to eval on initialisation
@end lisp

@item Meta-x remove-autoloads
@kindex Meta-x remove-autoloads
Remove all autoload forms from the @file{autoloads.jl} file which
are marked by the @code{;;;###autoload} comment in the current buffer.

The unsaved @file{autoloads.jl} buffer will become the current buffer.
@end table

@node Features, , Autoloading, Loading
@subsection Features
@cindex Features

@dfn{Features} correspond to modules of the editor. Each feature is
loaded separately. Each feature has a name, when a certain feature is
required its user asks for it to be present (with the @code{require}
function), the feature may then be used as normal.

When a feature is loaded one of the top-level forms evaluated is a call to
the @code{provide} function. This names the feature and installs it into
the list of present features.

@defvar features
A list of the features currently present (that is, loaded). Each feature
is represented by a symbol. Usually the print name of the symbol (the
name of the feature) is the same as the name of the file it was loaded
from, minus any @samp{.jl} or @samp{.jlc} suffix.

@lisp
features
    @result{} (info isearch fill-mode texinfo-mode lisp-mode xc)
@end lisp
@end defvar

@defun provide feature
Adds @var{feature} (a symbol) to the list of features present. A call
to this function is normally one of the top-level forms in a module.

@lisp
;;;; maths.jl -- the @code{maths} module

(provide 'maths)
@dots{}
@end lisp
@end defun

@deffn Command require feature &optional file
Show that the caller is planning to use the feature @var{feature} (a symbol).
This function will check the @code{features} variable to see if @var{feature}
is already loaded, if so it will return immediately.

If @var{feature} is not present it will be loaded. If @var{file} is
non-@code{nil} it specifies the first argument to the @code{load} function,
else the print name of the symbol @var{feature} is used.

@lisp
;;;; physics.jl -- the @code{physics} module

(require 'maths)                ;Need the @code{maths} module
(provide 'physics)
@dots{}
@end lisp

When called interactively the symbol @var{feature} is prompted for.
@end deffn

@node Compiled Lisp, Hooks, Loading, The language
@section Compiled Lisp
@cindex Compiled Lisp

Jade contains a rudimentary Lisp compiler; this takes a Lisp form or
program and compiles it into a @dfn{byte-code} form. This byte-code form
contains a string of byte instructions, a vector of data constants and
some other information.

The main reason for compiling your programs is to increase their speed, it
is difficult to quantify the speed increase gained --- some programs
(especially those using a lot of macros) will execute many times
quicker than their uncompiled version whereas others may only execute
a bit quicker.

@menu
* Compilation Functions::       How to compile Lisp programs
* Compilation Tips::            Getting the most out of the compiler
* Disassembly::                 Examining compiled functions
@end menu

@node Compilation Functions, Compilation Tips, , Compiled Lisp
@subsection Compilation Functions
@cindex Compilation functions
@cindex Functions, compilation

@defun compile-form form
This function compiles the Lisp form @var{form} into a byte-code form
which is returned.

@lisp
(compile-form '(setq foo bar))
    @result{} (jade-byte-code "F!" [bar foo] 2)
@end lisp
@end defun

@deffn Command compile-function function
This function replaces the uncompiled body of the function @var{function}
(a symbol) with a compiled version, then returns @var{function}.
@end deffn

@deffn Command compile-file file-name
This function compiles the file called @var{file-name} into a file of
compiled Lisp forms whose name is @var{file-name} with @samp{c} appended
to it (i.e. if @var{file-name} is @file{foo.jl} it will be compiled to
@file{foo.jlc}).

If an error occurs while the file is being compiled any semi-written
file will be deleted.

When called interactively this function will ask for the value of
@var{file-name}.
@end deffn

@deffn Command compile-directory directory &optional force exclude
Compiles all the Lisp files in the directory called @var{directory} which
either haven't been compiled or whose compiled version is older than
the source file (Lisp files are those ending in @samp{.jl}).

If the optional argument @var{force} is non-@code{nil} @emph{all} Lisp files
will be recompiled whatever the status of their compiled version.

The @var{exclude} argument may be a list of filenames, these files will
@emph{not} be compiled.

When this function is called interactively it prompts for the directory.
@end deffn

@defun compile-lisp-lib &optional force
Uses @code{compile-directory} to compile the library of standard Lisp files.
If @var{force} is non-@code{nil} all of these files will be compiled.

The @file{autoloads.jl} is @emph{never} compiled since it is often
modified and wouldn't really benefit from compilation anyway.
@end defun

@defun jade-byte-code byte-codes constants max-stack
Interprets the string of byte instructions @var{byte-codes} with
the vector of constants @var{constants}. @var{max-stack} defines the
maximum number of stack cells required to interpret the code.

This function is @emph{never} called by hand. The compiler will produce
calls to this function when it compiles a form or a function.

@lisp
(setq x 1
      y 3)
    @result{} 3
(setq comp (compile-form '(cons x y)))
    @result{} (jade-byte-code "K" [x y] 2)
(eval comp)
    @result{} (1 . 3)
@end lisp
@end defun

@node Compilation Tips, Disassembly, Compilation Functions, Compiled Lisp
@subsection Compilation Tips
@cindex Compilation tips
@cindex Tips, compilation

Here are some tips for making compiled code run fast:

@itemize @bullet
@item
Always favour iteration over recursion; function calls are relatively
slow. The compiler doesn't know about tail recursion or whatever so
you'll have to do this explicitly.

For example, the most elegant way of searching a list is to use
recursion,

@lisp
(defun scan-list (list elt)
  "Search the LIST for an element ELT. Return it if one is found."
  (if (eq (car list) elt)
      elt
    (scan-list (cdr list) elt)))
@end lisp

@noindent
but this is fairly slow. Instead, iterate through each element,

@lisp
(defun scan-list (list elt)
  (while (consp list)
    (when (eq (car list) elt)
      (return elt))
    (setq list (cdr list))))
@end lisp

@item
In some cases the functions @code{member}, @code{memq}, @code{assoc},
etc@dots{} can be used to search lists. Since these are primitives written
in C they will run @emph{much} faster than an equivalent Lisp function.

So the above @code{scan-list} example can be rewritten as,

@lisp
(defun scan-list (list elt)
  (car (memq elt list)))
@end lisp

Also note that the @code{mapcar} and @code{mapc} functions are useful
(and efficient) when using lists.

@item
Whenever possible use the @code{when} and @code{unless} conditional
structures; they are more efficient than @code{cond} or @code{if}.

@item
Careful use of named constants (@pxref{Constant Variables}) can increase
the speed of some programs. For example, in the Lisp compiler itself
all the opcode values (small integers) are defined as constants.

I must stress that in some cases constants are @emph{not} suitable;
they may drastically increase the size of the compiled program (when
the constants are `big' objects, i.e. long lists) or even introduce
subtle bugs (since two references to the same constant may not be
@code{eq} whereas two references to the same variable are always
@code{eq}).

@item
Many primitives have corresponding byte-code instructions; these primitives
will be quicker to call than those that don't (and incur a normal function
call). Currently, the functions which have byte-code instructions (apart
from all the special forms) are:

@code{cons}, @code{car}, @code{cdr}, @code{rplaca}, @code{rplacd}, @code{nth},
@code{nthcdr}, @code{aset}, @code{aref}, @code{length}, @code{eval}, @code{+},
@code{*}, @code{/}, @code{%}, @code{lognot}, @code{not}, @code{logior},
@code{logand}, @code{equal}, @code{eq}, @code{=}, @code{/=}, @code{>},
@code{<}, @code{>=}, @code{<=}, @code{1+}, @code{1-}, @code{-}, @code{set},
@code{fset}, @code{lsh}, @code{zerop}, @code{null}, @code{atom}, @code{consp},
@code{listp}, @code{numberp}, @code{stringp}, @code{vectorp}, @code{throw},
@code{fboundp}, @code{boundp}, @code{symbolp}, @code{get}, @code{put},
@code{signal}, @code{return}, @code{reverse}, @code{nreverse}, @code{assoc},
@code{assq}, @code{rassoc}, @code{rassq}, @code{last}, @code{mapcar}, @code{mapc},
@code{member}, @code{memq}, @code{delete}, @code{delq}, @code{delete-if},
@code{delete-if-not}, @code{copy-sequence}, @code{sequencep}, @code{functionp},
@code{special-formp}, @code{subrp}, @code{eql}, @code{set-current-buffer},
@code{current-buffer}, @code{bufferp}, @code{markp}, @code{windowp}.

@item
When a file is being compiled each top-level form it contains is inspected
to see if it should be compiled into a byte-code form. Different types
of form are processed in different ways:

@itemize @bullet
@item
Function and macro definitions have their body forms compiled into a single
byte-code form. The doc-string and interactive declaration are not compiled.

@item
Calls to the @code{require} function are evaluated then the unevaluated form
is written as-is to the output file. The reason it is evaluated is so that
any macros defined in the required module are loaded before they are
called by the program being compiled.

@item
If the form is a list form (@pxref{List Forms}) and the symbol which is
the car of the list is one of:

@code{if}, @code{cond}, @code{when}, @code{unless}, @code{let}, @code{let*},
@code{catch}, @code{unwind-protect}, @code{error-protect}, @code{with-buffer},
@code{with-window}, @code{progn}, @code{prog1}, @code{prog2}, @code{while},
@code{and}, @code{or}.

@noindent
then the form is compiled. Otherwise it is just written to the output file
in its uncompiled state.
@end itemize

If your program contains a lot of top-level forms which you know will
not be compiled automatically, consider putting them in a @code{progn}
block to make the compiler coalesce them into one byte-code form.
@end itemize

XXX Many of these so-called tips are no longer true...

@node Disassembly, , Compilation Tips, Compiled Lisp
@subsection Disassembly
@cindex Disassembly
@cindex Compilation, disassembly of forms

It is possible to disassemble byte-code forms; originally this was so
I could figure out why the compiler wasn't working but if you're
curious about how the compiler compiles a form it may be of use to
you.

Naturally, the output of the disassembler is a listing in Jade's
pseudo-machine language --- it won't take a byte-code form and produce
the equivalent Lisp code!

@deffn Command disassemble-fun function &optional stream
This function disassembles the compile Lisp function @var{function}. It
writes a listing to the output stream @var{stream} (normally the
value of the @code{standard-output} variable).

When called interactively it will prompt for a function to disassemble.
@end deffn

When reading the output of the disassembler bear in mind that Jade
simulates a stack machine for the code to run on. All calculations are
performed on the stack, the value left on the stack when the piece
of code ends is the value of the byte-code form.

@node Hooks, Files, Compiled Lisp, The language
@section Hooks
@cindex Hooks

A @dfn{hook} allows you to wedge your own pieces of Lisp code into
the editor's operations. These pieces of code are evaluated via the hook
and the result is available to the hook's caller.

@menu
* Functions As Hooks::          Some hooks are a single function,
* Normal Hooks::                Others may be a list of pieces of code
                                  to evaluate.
* Standard Hooks::              A table of the predefined hooks
@end menu

@node Functions As Hooks, Normal Hooks, , Hooks
@subsection Functions As Hooks
@cindex Functions as hooks
@cindex Hooks, functions as

Some hooks only allow a single piece of code to be hooked in. Usually
a normally-undefined function is used; to install your hook defined
a function with the name of the hook. When the hook is to be evaluated
the function is called.

Generally the name of the hook's function will end in @code{-function}.

An alternative scheme is to use a variable to store the hook, its value
should be the function to call.

@node Normal Hooks, Standard Hooks, Functions As Hooks, Hooks
@subsection Normal Hooks
@cindex Normal hooks
@cindex Hooks, normal

This is the standard type of hook, it is a variable whose value is a
list of functions. When the hook is evaluated each of the named functions
will be called in turn until one of them returns a value which is not
@code{nil}. This value becomes the value of the hook and no more of
the functions are called. If all of the functions in the hook return
@code{nil} the value of the hook is @code{nil}.

The names of hooks of this type will normally end in @code{-hook}.

@defun add-hook hook function &optional at-end
This function adds a new function @var{function} to the list of functions
installed in the (list) hook @var{hook} (a symbol).

If @var{at-end} is non-@code{nil} the new function is added at the end of
the hook's list of functions (and therefore will be called last when the
hook is evaluated), otherwise the new function is added to the front
of the list.

@lisp
text-mode-hook
    @result{} (fill-mode-on)
(add-hook 'text-mode-hook 'my-function)
    @result{} (my-function fill-mode-on)
@end lisp
@end defun

@defun remove-hook hook function
This function removes the function @var{function} from the list of functions
stored in the (list) hook @var{hook} (a symbol).

@emph{All} instances of @var{function} are deleted from the hook.

@lisp
text-mode-hook
    @result{} (my-function fill-mode-on)
(remove-hook 'text-mode-hook 'my-function)
    @result{} (fill-mode-on)
@end lisp
@end defun

@defun eval-hook hook &rest args
Evaluates the (list) hook @var{hook} (a symbol) with argument values @var{args}.

Each function stored in the hook is applied to the @var{args} in turn until
one returns non-@code{nil}. This non-@code{nil} value becomes the result
of the hook. If all functions return @code{nil} then the result of the
hook is @code{nil}.
@end defun

Note that most functions which are installed in hooks should always return
@code{nil} to ensure that all the functions in the hook are evaluated.

@node Standard Hooks, , Normal Hooks, Hooks
@subsection Standard Hooks
@cindex Standard hooks
@cindex Hooks, predefined

This is a table of the predefined hooks in Jade:

@table @code
@item idle-hook
@xref{Idle Actions}.
@end table

@node Files, Processes, Hooks, The language
@section Files
@cindex Files

Jade allows you to manipulate files in the operating system's filing
system; a special type of Lisp object, a @dfn{file object}, is used
to represent files which have been opened for reading or writing (through
the streams mechanism, @pxref{Streams}).

Names of files are represented by strings, the syntax of file names is
defined by the underlying operating system: Jade simply treats it as a
string.

@menu
* File Names::                  Files are named by a string
* File Objects::                Lisp objects representing files
* File Information::            Predicates on files
* Manipulating Files::          Deleting, renaming and copying files
* Reading Directories::         Getting a list of the files in a directory
* Reading and Writing Files::   Accessing the contents of a file in one go
* File Handlers::		Extending the file name-space
@end menu

@node File Names, File Objects, , Files
@subsection File Names
@cindex File names
@cindex Names of files

A @dfn{file name} is a string identifying an individual file (or directory)
in the filing system (i.e. the disk). The exact syntax of file names depends
on the operating system.

@defun file-name-directory file-name
This function returns the directory part of the file name string @var{file-name}.
This is the substring of @var{file-name} defining the directory containing
the file.

@lisp
(file-name-directory "/tmp/foo")
    @result{} "/tmp/"

(file-name-directory "foo")
    @result{} ""

(file-name-directory "foo/bar/")
    @result{} "/foo/bar/"
@end lisp
@end defun

@defun file-name-nondirectory file-name
Returns the substring of the file name @var{file-name} which is @emph{not}
the directory part.

@lisp
(file-name-nondirectory "/tmp/foo")
    @result{} "foo"

(file-name-nondirectory "foo")
    @result{} "foo"

(file-name-nondirectory "foo/bar/")
    @result{} ""
@end lisp
@end defun

@defun file-name-concat &rest parts
This function returns a file name constructed by concatenating each of the
@var{parts} of the file name together. Each part is separated by the
necessary string (i.e. @samp{/} on Unix) when necessary. Note that each
part may contain more than one component of the file name.

@lisp
(file-name-concat "/tmp" "foo" "bar")
    @result{} "/tmp/foo/bar"

(file-name-concat "/tmp/" "foo/" "bar")
    @result{} "/tmp/foo/bar"

(file-name-concat "/tmp/foo" "bar")
    @result{} "/tmp/foo/bar"
@end lisp
@end defun

@defun expand-file-name file-name &optional make-absolute
This function expands the string @var{file-name} into a valid file name.
Currently it only checks for a leading tilde character (@samp{~}) when running
on Unix, if one is found it's expanded to the user's home directory.

When the optional argument @var{make-absolute} is non-@code{nil} @var{file-name}
is altered so that it is not relative to the current working directory.
Generally this involves prefixing it by the absolute name of the current
directory.

@lisp
(expand-file-name "~/src")
    @result{} "/home/jsh/src"

(expand-file-name "foo.c" t)
    @result{} "/var/src/jade/foo.c"
@end lisp
@end defun

@defun make-temp-name
This function returns the name of a file which, when created, may be used
for temporary storage. Each time this function is called a unique name is
computed.

@lisp
(make-temp-name)
    @result{} "/tmp/00088aaa"

(make-temp-name)
    @result{} "/tmp/00088baa"
@end lisp
@end defun

XXX Other functions to document: @code{directory-file-name},
@code{file-name-as-directory}, @code{canonical-file-name},
@code{local-file-name}, ..? Also @code{expand-file-name} has changed
its parameters and @code{file-name-concat} has been deleted

@node File Objects, File Information, File Names, Files
@subsection File Objects
@cindex File objects

A file object is a Lisp object which represents a file in the filing
system. Any file object may be used as a stream (either input or output)
to access the contents of the file serially, @ref{Streams}.

@menu
* Creating File Objects::       Opening files
* Destroying File Objects::     Closing files
* File Object Predicates::      Predicates for file objects
* Functions on File Objects::   Functions operating on file objects
@end menu

@node Creating File Objects, Destroying File Objects, , File Objects
@subsubsection Creating File Objects
@cindex Creating file objects
@cindex File objects, creating
@cindex Files, opening

@defun open file-name mode-string &optional file-object
This function opens the file called @var{file-name} (@pxref{File Names})
and returns the file's object.

The @var{mode-string} argument is a string defining the access modes used
to open the file with; this string is passed as-is to the C library's
@code{fopen()} function. Usually one of the following strings is used,

@table @samp
@item r
Open an existing file for reading only.

@item w
Open the file for writing only, if the file exists it is truncated to
zero length. Otherwise a new file is created.

@item a
Open the file for appending to, i.e. writing to the end of the file. If
the file doesn't exist it is created.
@end table

Other options exist; consult a C library manual for details.

When the @var{file-object} argument is defined it should be a file object,
the file it points to will be closed and the new file will be opened on
this object.
@end defun

XXX This has changed to @code{open-file}, and the parameters have
changed

@node Destroying File Objects, File Object Predicates, Creating File Objects, File Objects
@subsubsection Destroying File Objects
@cindex Destroying file objects
@cindex File objects, destroying
@cindex Files, closing

The easiest way to close a file is simply to eliminate all references to it,
subsequently the garbage collector will close it for you. It is better
to close files explicitly though since only a limited number of files may be
opened concurrently.

@defun close-file file-object
This function closes the file pointed to by the file object @var{file-object}.

Until a new file is opened on @var{file-object} any read/write accesses
to it are illegal and an error will be signalled.
@end defun

@node File Object Predicates, Functions on File Objects, Destroying File Objects, File Objects
@subsubsection File Object Predicates
@cindex File object predicates

@defun filep object
This function returns @code{t} when its argument is a file object.
@end defun

@defun file-bound-p file-object
Returns @code{t} when the file object @var{file-object} is currently
bound to a physical file (i.e. the @code{close} function hasn't been
called on it yet).
@end defun

@node Functions on File Objects, , File Object Predicates, File Objects
@subsubsection Functions on File Objects
@cindex Functions on File Objects
@cindex File objects, functions

@defun flush-file file-object
This function flushes any buffered output to the file object @var{file-object}
to disk.

Note that when using a file which was opened with the @samp{+} option
it's necessary to call this function when switching from reading to
writing or vice versa.
@end defun

@defun file-binding file-object
Returns the name of the file which the file object @var{file-object} is
currently bound to.
@end defun

@node File Information, Manipulating Files, File Objects, Files
@subsection File Information
@cindex File information

A number of functions exist which when given the name of a file return
some information about that file.

@defun file-exists-p file-name
Returns @code{t} when a file @var{file-name} exists.
@end defun

@defun file-regular-p file-name
Returns @code{t} when the file @var{file-name} is a `normal' file. This means
that it isn't a directory, device, symbolic link or whatever.
@end defun

@defun file-directory-p file-name
Returns @code{t} when the file @var{file-name} is a directory.
@end defun

@defun file-symlink-p file-name
Returns @code{t} when the file @var{file-name} is a symbolic link.
@end defun

@defun file-readable-p file-name
Returns @code{t} when the file @var{file-name} is readable.
@end defun

@defun file-writable-p file-name
Returns @code{t} when the file @var{file-name} is writable.
@end defun

@defun file-owner-p file-name
Returns @code{t} when the ownership of the file @var{file-name} is
the same as that of any files written by the editor.

Note that currently this always returns @code{t} in the Amiga version.
@end defun

@defun file-nlinks file-name
Returns the number of hard links pointing to the file @var{file-name}. If
@var{file-name} has only one name the number will be one.

Note that this always returns one in the Amiga version of Jade.
@end defun

@defun file-modes file-name
This function returns the access permissions of the file @var{file-name}.
This will be an integer whose format is undefined; it differs from
operating system to operating system.
@end defun

@defun set-file-modes file-name modes
This function sets the access permissions of the file @var{file-name} to
the integer @var{modes} (as returned by the @code{file-modes} function).
@end defun

@defun file-modtime file-name
Returns the system time at the last modification to the file @var{file-name},
this will be an integer. @xref{System Time}.
@end defun

@defun file-newer-than-file-p file-name1 file-name2
This function returns @code{t} if the file @var{file-name1} was modified
more recently than the file @var{file-name2} was.

@lisp
(file-newer-than-file-p @var{file1} @var{file2})
@equiv{}
(> (file-modtime @var{file1}) (file-modtime @var{file2}))
@end lisp
@end defun

@node Manipulating Files, Reading Directories, File Information, Files
@subsection Manipulating Files
@cindex Manipulating files
@cindex Files, manipulating

@deffn Command delete-file file-name
This function deletes the file called @var{file-name}. When called
interactively @var{file-name} is prompted for.
@end deffn

@deffn Command rename-file file-name new-name
This function attempts to change the name of the file @var{new-name}
to @var{new-name}.

This won't work from one file system to another or if a file called
@var{new-name} already exists, in these cases an error is signalled.

This prompts for its arguments when called interactively.
@end deffn

@deffn Command copy-file file-name destination-name
Creates a new copy of the file @var{file-name} with the name
@var{destination-name}.

The access modes of the new file will be the same as those of the original
file.

The arguments are prompted for when this function is called interactively.
@end deffn

@node Reading Directories, File Handlers, Manipulating Files, Files
@subsection Reading Directories
@cindex Reading directories
@cindex Files, reading directories

@defun directory-files directory-name
This function returns a list of the names of all files in the directory
whose file name is @var{directory-name}. The names in the list will be
relative to the directory @var{directory-name}, any directories in
the list will have a @samp{/} character appended to them.

@lisp
(directory-files "/tmp/foo"
    @result{} ("bar" "subdir/" "xyz" "." "..")
@end lisp
@end defun

@node File Handlers, , Reading Directories, Files
@subsection File Handlers
@cindex File Handlers


@node Processes, Miscellaneous Functions, Files, The language
@section Processes
@cindex Processes

When running on a Unix-style operating system (i.e. the X11 version) Jade
allows you to launch and control an arbitrary number of subprocesses. These
subprocesses can run either synchronously or asynchronously in respect to
the editor; data can be sent to the stdin channel and any output from
the process is automatically written to a programmer-defined Lisp stream.

Currently there is @emph{no} way to manipulate subprocesses in the Amiga
version of Jade (sorry!).

@menu
* Process Objects::             Lisp objects associated with subprocesses
* Asynchronous Processes::      Subprocesses running in parallel with Jade
* Synchronous Processes::       Subprocesses which Jade runs serially
* Process I/O::                 Input and output with subprocesses
* Process States::              Suspending subprocesses
* Signalling Processes::        Sending signals to subprocesses
* Process Information::         Information stored in a process object
@end menu

@node Process Objects, Asynchronous Processes, , Processes
@subsection Process Objects
@cindex Process objects

A @dfn{process object} is a type of Lisp object used to provide a link
between a `physical' process running in the operating system and Jade's
Lisp system. Each process object consists of a number of components (references
to other Lisp objects); these components are used when the object is
used to run a subprocess.

Process objects which aren't currently being used to run a subprocess
store the exit value of the last subprocess which was run on that object.

@defun processp object
This function returns @code{t} when its argument is a process object.
@end defun

The programmer-accessible components of a process object are,

@table @dfn
@item Output stream
A normal Lisp output stream (@pxref{Output Streams}), all data which the
subprocess outputs to its @code{stdout} channel is copied to this
output stream. @xref{Process I/O}.

@item State change function
A Lisp function, called each time the state of the subprocess being run
on the object changes. @xref{Process States}.

@item Program name
The name of the program (a string) to execute when the subprocess is created.

@item Program arguments
A list of strings defining the arguments which the program executed
is given.

@item Directory
When a subprocess is started its current working directory is set to
the directory named by this component of its process object.

@item Connection type
Asynchronous subprocesses (@pxref{Asynchronous Processes}) use this
component to decide how to connect to the I/O channels of the subprocess.
Current options include pseudo-terminals and pipes.
@end table

@defun make-process &optional output-stream state-function directory program args
This functions creates and returns a new process object. @emph{No subprocess
will be started.}

The optional arguments are used to define the values of the components of
the new process object, any undefined components will be set to default
or null values.
@end defun

For each component of a process object two functions exist; one to
read the component's value in a specific process object, the other
to set the component's value.

@defun process-prog process
Returns the value of the program name component of the process object
@var{process}.
@end defun

@defun set-process-prog process prog-name
Sets the value of the program name component of the process object
@var{process} to the string @var{prog-name}, then returns @var{prog-name}.
@end defun

@defun process-args process
Returns the value of the program arguments component of the process object
@var{process}.
@end defun

@defun set-process-args process arg-list
Sets the value of the program arguments component of the process object
@var{process} to the list @var{arg-list}, then returns @var{arg-list}.
@end defun

@defun process-dir process
Returns the value of the directory component of the process object
@var{process}.
@end defun

@defun set-process-directory process directory
Sets the value of the directory component of the process object
@var{process} to the string @var{directory}, then returns @var{directory}.
@end defun

@node Asynchronous Processes, Synchronous Processes, Process Objects, Processes
@subsection Asynchronous Processes
@cindex Asynchronous processes
@cindex Processes, asynchronous

An @dfn{asynchronous process} is one that runs in parallel with the editor,
basically this means that once the subprocess has been started (by the
@code{start-process} function) Jade will carry on as normal.

The event loop checks for output from asynchronous processes, any found
is copied to the process' output stream, and calls the the process' state
change function when necessary (@pxref{Process States}).

When using asynchronous processes you have a choice as to the Unix
mechanism used to connect the @code{stdin}, @code{stdout} and @code{stderr}
streams of the subprocess to Jade's process (note that whatever the choice
@code{stdout} and @code{stderr} always go to the same place).

The two options currently available are pipes or pseudo-terminals; in
general pseudo-terminals should only be used to provide a direct interface
between the user and a process (i.e. the @samp{*shell*} buffer) since they
allow job control to work properly. At other times pipes will be more
efficient and are used by default.

@defun start-process &optional process-object program &rest args
This function starts an asynchronous subprocess running on the process
object @var{process-object}. If @var{process-object} is undefined a
new process object is created (by calling the function @code{make-process}
with all arguments undefined).

The function always returns the process object which the subprocess
has been started on. If for some reason the subprocess can't be created
an error of type @code{process-error} is signalled.

The optional argument @var{program} is a string defining the name of the
program to execute, it will be searched for in all the directories
in the @code{PATH} environment variable. The @var{args} are strings
to pass to the subprocess as its arguments.

When defined, the optional arguments overrule the values of the related
components of the process object.

The following example runs the @code{ls} program asynchronously, its output
is inserted into the current buffer.

@lisp
(let
    ((process (make-process (current-buffer))))
  (start-process process "ls" "-s"))
@end lisp
@end defun

Note that when Jade terminates it kills all of its asynchronous
subprocesses which are still running without warning.

@defun process-connection-type process
Returns the value of the connection type component of the process object
@var{process}. See the documentation of the @code{set-process-connection-type}
function for the values this may take.
@end defun

@defun set-process-connection-type process symbol
Sets the value of the connection type component of the process object
@var{process} to @var{symbol}, then returns @var{symbol}.

@var{symbol} should be one of the following symbols,

@table @code
@item pty
Use pseudo-terminals to connect to subprocesses running asynchronously on
this process object.

@item pipe
Use standard Unix pipes to connect, this is the default value of this
component.
@end table
@end defun

@node Synchronous Processes, Process I/O, Asynchronous Processes, Processes
@subsection Synchronous Processes
@cindex Synchronous processes
@cindex Processes, synchronous

When a @dfn{synchronous process} is started Jade waits for it to
terminated before continuing; they are usually used when a Lisp program
must invoke an external program as part of its function, i.e. the
auto-compression feature runs the compression program @code{gzip}
synchronously when it needs to compress a buffer.

Unlike asynchronous processes their is no choice between pipes and
pseudo-terminals for connecting to a subprocess. Instead, it is possible
to link the @code{stdin} channel of a synchronous process to a named
file.

@defun run-process &optional process-object input-file-name program &rest args
This function starts a process running on the process object
@var{process-object}. If @var{process-object} is undefined a new process object
is created by calling the @code{make-process} function.

If defined, the string @var{input-file-name} names the file to connect to
the standard input of the subprocess, otherwise the subprocess' input
comes from the null device (@file{/dev/null}).

The optional arguments @var{program} and @var{args} define the name of the
program to invoke and any arguments to pass to it. The program will be searched
for in all directories listed in the @code{PATH} environment variable.

If any of the optional parameters are unspecified they should have been
set in the @var{process-object} prior to calling this function.

After successfully creating the new subprocess, this function simply copies
any output from the process to the output stream defined by the output stream
component of the process object. When the subprocess exits its exit-value
is returned (an integer). Note that the exit-value is the value returned
by the @code{process-exit-value} function, see @ref{Process Information}.

If, for some reason, the new subprocess can't be created an error of type
@code{process-error} is signalled.
@end defun

The following function definition is taken from the @file{gzip.jl} file,
it shows how the @code{run-process} function can be used to uncompress
a file into a buffer.

@lisp
;; Uncompress FILE-NAME into the current buffer
(defun gzip-uncompress (file-name)
  (let
      ((proc (make-process (current-buffer))))
    (message (concat "Uncompressing `" file-name "'") t)
    ;; gunzip can do .Z files as well
    (unless (zerop (run-process proc nil "gunzip" "-c" file-name))
      (signal 'file-error (list "Can't gunzip file" file-name)))))
@end lisp

@node Process I/O, Process States, Synchronous Processes, Processes
@subsection Process I/O
@cindex Process I/O

It is only possible for lisp programs to explicitly send input data
to @emph{asynchronous} processes (by the time it's possible to call a function
to send data to a synchronous process, the process will already have
terminated!). Simply use the process object which an asynchronous process
is running on as a normal Lisp input stream, any strings or characters
written to the stream will immediately be copied to the @code{stdin} channel
of the subprocess.

With synchronous processes, the only control over input data possible is
by giving the @code{run-process} function the name of a file containing
the subprocess' input data.

Output data from subprocesses is handled the same way by both asynchronous
and synchronous processes: it is simply copied to the stream defined by
the output stream component of the subprocess' process object.

@defun process-output-stream process
Returns the value of the output stream component of the process object
@var{process}.
@end defun

@defun set-process-output-stream process stream
Sets the value of the output stream component of the process object
@var{process} to the stream @var{stream}, then returns @var{stream}.
@end defun

@xref{Streams}.

@node Process States, Signalling Processes, Process I/O, Processes
@subsection Process States
@cindex Process states

Each process object has a @dfn{state} associated with it; this depends on
the status of the subprocess currently running on the process object (or
not as the case may be).

The possible states are,

@table @dfn
@item running
This state means that the subprocess using this process object is currently
running, i.e. it hasn't been stopped.

@item stopped
Means that the subprocess has been temporarily suspended from running.

@item unused
This means that the process object is free to have a new subprocess created
on it.
@end table

Predicates exist which test whether a given process object is in one of
these states.

@defun process-running-p process-object
Returns @code{t} when @var{process-object} is in the running state.
@end defun

@defun process-stopped-p process-object
Returns @code{t} when @var{process-object} is in the stopped state.
@end defun

@defun process-in-use-p process-object
Returns @code{t} when @var{process-object} is @emph{not} in the unused
state.
@end defun

The following two functions are used to stop and then subsequently
continue a process running.

@defun stop-process process-object &optional whole-group
This function suspends execution of the subprocess running on the
process object @var{process-object}.

If @var{whole-group} is non-@code{nil} all subprocesses in the
process group of @var{process-object} are stopped.
@end defun

@defun continue-process process-object &optional whole-group
Use this function to continue a subprocess executing after it has been
stopped (by the @code{stop-process} function).

If @var{whole-group} is non-@code{nil} all subprocesses in the
process group of @var{process-object} are continued.
@end defun

The state change function component of a process object defines a function
which will be called each time the state of the process object changes. If
your program needs to be informed when an asynchronous process terminates
this function is the way to do it.

@defun process-function process
Returns the value of the state change function component of the process object
@var{process}.
@end defun

@defun set-process-function process function
Sets the value of the state change function component of the process object
@var{process} to the function @var{function}, then returns @var{function}.
@end defun

@node Signalling Processes, Process Information, Process States, Processes
@subsection Signalling Processes
@cindex Signalling processes
@cindex Processes, signalling

@defun signal-process process-object signal-number &optional whole-group
If the process object @var{process-object} is being used to run an asynchronous
subprocess send the signal numbered @var{signal-number} to it.

When the optional argument @var{whole-group} is non-@code{nil} the
signal is also sent to all processes in the process group of the subprocess.
@end defun

The following functions use the @code{signal-process} function to send some
common signals to processes.

@defun interrupt-process process-object &optional whole-group
Sends the @code{SIGINT} signal to @var{process-object}.

@lisp
(interrupt-process @var{process-object} @var{whole-group})
@equiv{}
(signal-process @var{process-object} @code{SIGINT} @var{whole-group})
@end lisp
@end defun

@defun kill-process process-object &optional whole-group
Sends the @code{SIGKILL} signal to the @var{process-object}.

@lisp
(kill-process @var{process-object} @var{whole-group})
@equiv{}
(signal-process @var{process-object} @code{SIGKILL} @var{whole-group})
@end lisp
@end defun

Note that the functions @code{stop-process} and @code{continue-process}
also send signals to the subprocess.

@node Process Information, , Signalling Processes, Processes
@subsection Process Information
@cindex Process information

@defun process-id process-object
This function returns the operating-system identifier associated with the
subprocess currently running on the process object @var{process-object}.
@end defun

@defun process-exit-value process-object
Returns the integer representing the return code of the last subprocess
to be run on @var{process-object}.

If no subprocess has been run on @var{process-object}, @var{process-object}
is currently in the running state or the last subprocess exited abnormally
(i.e. from a terminal signal) @code{nil} is returned.
@end defun

@defun process-exit-status process-object
This function returns the integer that was the exit status of the last
subprocess which was run on the process object @var{process-object}.

Note that the exit status is @emph{not} the value given to the @code{exit}
function in a C program, use the @code{process-exit-value} to access this
value.

If no process has been run on @var{process-object}, or the process is currently
in the running state @code{nil} is returned.
@end defun

@node Miscellaneous Functions, Debugging, Processes, The language
@section Miscellaneous Functions
@cindex Miscellaneous functions

This section of the manual documents functions and features which don't
comfortably fit elsewhere in this manual.

@menu
* System Information::          Getting details about the host
* User Information::            The name of the user
* Environment Variables::       Reading and writing the environment
* System Time::                 Getting the current time
* Revision Information::        How to check Jade's revision numbers
@end menu

@node System Information, User Information, , Miscellaneous Functions
@subsection System Information
@cindex System information

@defun x11-p
This function returns @code{t} when Jade is running on the X11 window system.
@end defun

@defun unix-p
This function returns @code{t} when Jade is running on a variant of the Unix
operating system.
@end defun

@defun amiga-p
This function returns @code{t} when Jade is running on an Amiga.
@end defun

@defun system-name
This function returns a string naming the host that Jade is running on. When
possible this will include the name of the domain as well.

In the Amiga version of Jade the environment variable @code{HOSTNAME} is
assumed to contain the host's name.
@end defun

@node User Information, Environment Variables, System Information, Miscellaneous Functions
@subsection User Information
@cindex User information

@defun user-login-name
This function returns a string containing the login name of the user.

In the Amiga version this is taken from the environment variable
@code{USERNAME}.

@lisp
(user-login-name)
    @result{} "jsh"
@end lisp
@end defun

@defun user-real-name
This function returns a string containing the `real' name of the user; the
format of the string will depend on the host system.

In the Amiga version this is taken from the @code{REALNAME} environment
variable.

@lisp
(user-real-name)
    @result{} "John Harper"
@end lisp
@end defun

@defun user-home-directory
This function returns the name of the user's home directory terminated by
a slash character (@samp{/}).

The first place this is looked for is in the @code{HOME} environment
variable; if this variable doesn't exist we either use the @file{SYS:}
logical device in AmigaDOS or consult the passwd file when in Unix.

@lisp
(user-home-directory)
    @result{} "/home/jsh/"
@end lisp
@end defun

@node Environment Variables, System Time, User Information, Miscellaneous Functions
@subsection Environment Variables
@cindex Environment variables

@defun getenv variable-name
This function returns the value (a string) of the environment variable
called @var{variable-name}. If the specified variable doesn't exist @code{nil}
is returned.

@lisp
(getenv "OSTYPE")
    @result{} "Linux"
@end lisp
@end defun

@defun setenv variable-name new-value
This function sets the value of the environment variable called
@var{variable-name} to @var{new-value}. @var{new-value} can either be
a string containing the new contents of the variable or @code{nil}, in which
case the environment variable is deleted.
@end defun

@node System Time, Revision Information, Environment Variables, Miscellaneous Functions
@subsection System Time
@cindex System time
@cindex Time, system
@cindex Current time

No matter what operating system Jade is running on it always an integer
to store a time value. Generally this will be the number of seconds since
some previous date.

The only thing a Lisp program is allowed to assume about a time value is
that as time passes the time value @emph{increases}. This means that it's
possible to compare two time values and know which is the newer.

@defun current-time
Returns an integer denoting the current time.

@lisp
(current-time)
    @result{} 780935736
@end lisp
@end defun

@defun current-time-string
This function returns a string stating the current time and date in a fixed
format. An example of the format is,

@example
Fri Sep 30 15:20:56 1994
@end example

Each field will always be in the same place, for example,

@example
Thu Sep  1 12:13:14 1994
@end example

@lisp
(current-time-string)
    @result{} "Fri Sep 30 15:20:56 1994"
@end lisp
@end defun

@node Revision Information, , System Time, Miscellaneous Functions
@subsection Revision Information
@cindex Revision information
@cindex Version numbers

@defun major-version-number
This function returns a number defining the major version of the editor.

@lisp
(major-version-number)
    @result{} 3
@end lisp
@end defun

@defun minor-version-number
Returns a number defining the minor version of the editor.

@lisp
(minor-version-number)
    @result{} 2
@end lisp
@end defun

@node Debugging, Tips, Miscellaneous Functions, The language
@section Debugging
@cindex Debugging

When you have written a Lisp program you will have to debug it (unless
all your programs work first time?). There are two main classes of errors;
syntax errors and semantic errors.

Syntax errors occur when the text you've typed out to represent your
program is not a valid representation of a Lisp object (since a program is
simply an ordered set of Lisp objects). When you try to load your program
the Lisp reader will find the syntax error and tell you about, unfortunately
though it probably won't be able to tell you exactly where the error is.

The most common source of syntax errors is too few or too many parentheses;
the @kbd{Ctrl-Meta-f} and @kbd{Ctrl-Meta-b} commands can be used to show
the structure of the program as the Lisp reader sees it.

Semantic errors are what we normally call bugs --- errors in logic, the program
is syntactically correct but doesn't do what you want it to. For these
types of errors Jade provides a simple debugger which allows you to single
step through the Lisp forms of your program as they are being evaluated.

There are several ways to enter the Lisp debugger; functions can be marked
so that they cause the debugger to be entered when they are called, breakpoints
can be written in functions or it can be called explicitly with a form to
step through.

@deffn Command trace symbol
This command marks the symbol @var{symbol} so that each time the function
stored in the function cell of @var{symbol} is called the debugger is
entered immediately.

When called interactively @var{symbol} is prompted for.
@end deffn

@deffn Command untrace symbol
The opposite of @code{trace} --- unmarks the symbol.
@end deffn

@defun break
This function causes the debugger to be entered immediately. By putting the
form @code{(break)} at suitable points in your program simple breakpoints
can be created.
@end defun

@deffn Command step form
This function invokes the debugger to step through the form @var{form}.

When called interactively @var{form} is prompted for.
@end deffn

Whenever the Lisp debugger is entered the form waiting to be evaluated
is printed at the bottom of the buffer, at this point the special debugger
commands available are,

@table @kbd
@item Ctrl-c Ctrl-s
@kindex Ctrl-c Ctrl-s
Step into the current form; this means that in a list form the debugger is
used to evaluated each argument in turn.

@item Ctrl-c Ctrl-i
@kindex Ctrl-c Ctrl-i
Ignore the current form; makes the current form immediately return @code{nil}.

@item Ctrl-c Ctrl-n
@kindex Ctrl-c Ctrl-n
Continue evaluating forms normally until the next form at the current level
is entered, then re-enter the debugger.

@item Ctrl-c Ctrl-r
@kindex Ctrl-c Ctrl-r
Continue execution normally. Note that this command is the one to use when
an error has been trapped.

@item Ctrl-c Ctrl-b
@kindex Ctrl-c Ctrl-b
Print a backtrace of the current Lisp call stack, note that calls of
primitive functions aren't currently recorded in this stack.

@item Ctrl-c Ctrl-x
@kindex Ctrl-c Ctrl-x
Prompt for a Lisp form, evaluate it and return this value as the result of
the current form.
@end table

After the form has been evaluated (i.e. after you've typed one of the
commands above) the value of the form is printed in the buffer, prefixed by
the string @samp{=> }.

Note that it is also possible to make certain types of errors invoke the
debugger immediately they are signalled, see @ref{Errors}.

@node Tips, , Debugging, The language
@section Tips
@cindex Tips

This section of the manual gives advice about programming in Jade.

Obviously there is no @emph{need} to religiously follow every single
one, but following these tips will make your programs easier to
read and (hopefully) more efficient overall.

For advice on getting the most out of the compiler, see @ref{Compilation Tips}.

@menu
* Comment Styles::              Differrent types of comments
* Program Layout::              How I lay out the programs I write
* General Tips::                Do's and Don't's of Jade programming
@end menu

@node Comment Styles, Program Layout, , Tips
@subsection Comment Styles
@cindex Comment styles
@cindex Tips, comment styles
@cindex Style, comments

As already described, single-line comments in Lisp are introduced by
a semi-colon (@samp{;}) character. By convention a different number of
semi-colons is used to introduce different types of comments,

@table @samp
@item ;
A comment referring to the line of Lisp code that it occurs on, comments
of this type are usually indented to the same depth, on the right of the
Lisp code. When editing in Lisp mode the command @kbd{Meta-;} can be used
to insert a comment of this type.

For example,

@lisp
(defconst op-call 0x08)	        ;call (stk[n] stk[n-1] ... stk[0])
                                ; pops n values, replacing the
                                ; function with the result.
(defconst op-push 0x10)	        ;pushes constant # n
@end lisp

@item ;;
Comments starting with two semi-colons are written on a line of their
own and indented to the same depth as the next line of Lisp code. They
describe the following lines of code.

For example,

@lisp
;; Be sure to remove any partially written dst-file.
(let
    ((fname (concat file-name ?c)))
  (when (file-exists-p fname)
    (delete-file fname)))
@end lisp

Comments of this type are also placed before a function definition
to describe the function. This saves wasting memory with a documentation
string in a module's internal functions.

For example,

@lisp
;; Compile a form which occurred at the `top-level' into a
;; byte code form.
;; defuns, defmacros, defvars, etc... are treated specially.
;; require forms are evaluated before being output uncompiled;
;; this is so any macros are brought in before they're used.
(defun comp-compile-top-form (form)
  @dots{}
@end lisp

@item ;;;
This type of comment always starts in the first column of the line, they
are used to make general comments about a program and don't refer to any
function or piece of code in particular.

For example,

@lisp
;;; Notes:
;;;
;;; Instruction Encoding
;;; ====================
;;; Instructions which get an argument (with opcodes of zero up to
@dots{}
@end lisp

@item ;;;;
Each program should have a comment of this type as its first line, the
body of the comment is the name of the file, two dashes and a brief
description of what the program does. They always start in the first
column.

For example,

@lisp
;;;; compiler.jl -- Simple compiler for Lisp files/forms
@end lisp
@end table

If you adhere to these standards the indentation functions provide by
the Lisp mode will indent your comments to the correct depth.

@node Program Layout, General Tips, Comment Styles, Tips
@subsection Program Layout
@cindex Program layout
@cindex Tips, program layout
@cindex Layout of programs

The layout that I have used for all the Lisp programs included with
Jade is as follows, obviously this isn't ideal but it seems ok.

@enumerate
@item
The first line of the file is the header comment, including the
name of the file and its general function.

@item
Copyright banner.

@item
Any @code{require} forms needed followed by a @code{provide} form for
this module. The @code{require} forms should be before the
@code{provide} in case the required modules aren't available.

@item
Variable and constant definitions. As a variable is defined any
initialisation it needs is done immediately afterwards. For example
a keymap is defined with @code{defvar} then initialised with
the @code{bind-keys} function.

For example,

@lisp
(defvar debug-buffer (make-buffer "*debugger*")
  "Buffer to use for the Lisp debugger.")
(set-buffer-special debug-buffer t)
(add-buffer debug-buffer)

(defvar debug-ctrl-c-keymap (make-keylist)
  "Keymap for debugger's ctrl-c prefix.")
(bind-keys debug-ctrl-c-keymap
  "Ctrl-s" 'debug-step
  @dots{}
@end lisp

@item
Finally the functions which make up the program, it often improves
readability if the entry points to the program are defined first.
@end enumerate

@node General Tips, , Program Layout, Tips
@subsection General Tips
@cindex General tips
@cindex Tips, general

The following are some general items of advice; you don't have to follow
them but they are the result of experience!

@itemize @bullet
@item
Jade only has one name-space for all the symbols ever created, this could
lead to naming clashes if care isn't taken.

When you write a program all the symbols it creates should be prefixed
by a name derived from the name of the program in some way. For example,
in the program @file{isearch.jl} all functions and variable names are
prefixed by the string @samp{isearch-}, giving @code{isearch-cancel}
and so on. Note that the prefix doesn't have to be the exact name of the
file, the program @file{buffer-menu.jl} uses the prefix @samp{bm-}.

The entry points to a module (i.e. the names of the commands it provides)
should @emph{not} have a prefix, simply give them a descriptive name (but
try not to make it too long!).

Don't bother giving local variables these prefixes unless they are used
by several functions in the program.

@item
Use the @code{recursive-edit} function as little as possible; it can be
@emph{very} confusing for the user! When at all possible use keymaps to
create user interfaces.

@item
Use the Lisp mode to indent your programs; not only does it save a lot
of time it also makes it easier for other people to read them.

@item
Errors should always be reported by either @code{error} or @code{signal},
don't just print a message or call @code{beep}.

@item
Don't redefine existing functions unless absolutely possible: try to
use hooks. If there is no hook where you want one, mail me about it and
I may put one in the next release.

@item
Don't compile your program until you're sure it works! The debugger only
works properly with uncompiled code.

@item
Use constants sparingly: personally, I only use them where the constants
are numeric.

@item
Remember to define macros before they are used, otherwise they won't be
compiled inline. The same can happen if you don't @code{require} a file
that a macro is defined in before using the macro definition.

@item
As I said in the compilation tips (@pxref{Compilation Tips}), try to
use iteration instead of recursion. Also the @code{memq} and @code{assq}
types of functions can be used to search some types of list structures
very quickly.

@item
When writing modes don't bind any unmodified keys to the prefix @kbd{Ctrl-c},
these are reserved for customisation by users.
@end itemize
