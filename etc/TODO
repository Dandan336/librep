[ This is -*-Indented-Text-*- ]

TODO list for librep
********************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -

modules
=======

 ! fix dump.jl

 ! ref cache can thrash when switching structures quickly

   also, the first level lookup of foo#bar isn't cached

 ! autoload is kind of fucked

   (you have to create the autoload stub in the module that the
   function will get loaded into)


Outstanding bugs
================

 ! doesn't handle NaN or Inf in floats properly (at all)

 ! ((call/cc call/cc) (call/cc call/cc)) can't be interrupted, and it
   eats all memory

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! It's relatively easy to blow the stack when regexp matching. Try
   searching for `/\*(.|\n)*\*/' in a C file with reasonable large
   comments.

 ! If a compiled file FOO.jlc is made from source file FOO, but FOO is
   newer, load doesn't notice, and loads the invalid FOO.jlc

 ! it's impossible for scripts to present their own --help option

 ! non-fixnum numbers can't be dumped

 ! `random' only accepts its range as a fixnum

 ! unwind-protect may not evaluate it's cleanup forms, consider:

   (call/cc (lambda (exit)
	      (unwind-protect
		  (exit)
		(message "Foo!"))))
   
   Just call this a [mis-] feature for now..

 ! compiler tail-recursion elimination doesn't figure when the binding
   has been changed; e.g. (let loop ((foo t)) (setq loop print) (loop foo))

   need to check for setq's on lexical variables... also need to only
   allow set to modify special variables

 + remove op-dset instruction (a bad mistake, unused by current compiler)


General programming tasks:
==========================

 - the gc sucks

   raising garbage-threshold to 200k helps, but gc still takes about
   25% of cpu time for the gtk-glue.c build time

   the current gc has a tradeoff between mark time and sweep time,
   raising the threshold decreases cumulative mark time, but increases
   sweep time. Increasing the threshold to 400k still reduces the
   overall time, but only by about 4% over the 200k value

   is it possible to add a good gc?

   maybe add a compile time option to use the Boehm conservative gc?

 - remove special forms (replacing them with macros) where both
   possible and desirable

   The current (29-3-99) list of special forms is:

   case catch cond condition-case defvar lambda prog1 progn quote setq
   unwind-protect while with-object

 - eliminate tail calls in interpreted code

 - add a hygienic macro facility

 - do JIT compilation of bytecode where profitable

   there's now GNU lightning, a VCODE-like system, using C macros to do
   portable runtime code generation

   Only do this for _heavily_ used bytecode subrs. Measure this by
   adding an extra vector slot, and counting the number of vm
   iterations

 - Optimize compilation of case statements

   1. handle constant keys

   2. optimize the search

 - Eliminate lexically-bound symbols from compiled code?

   currently the symbols are only used when the binding is created; all
   access is done through lexical addressing.

   lexical leaf procedures (i.e. those without any `enclose' or
   `make-closure' instructions) don't need to include symbols, since
   there's no way they could be needed

 - Sandboxed bytecode interpreter

   the default vm assumes that the compiler makes no errors (i.e. it
   ignores some range/type checks)

   a `safe' vm would check for things like:

     * stack overflow
     * range of indices to the vector of constants
     * validity of refg/setg instructions
     * invalid lexical addresses to refn/setn
     * etc..

   implement this as a plugin?

 - Implement weak-pairs or equivalent

   could use normal cons types for this, but allocate from a `weak'
   freelist, then only gc has to differentiate between weak and
   non-weak pairs

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Add more backends for accessing remote files

   Make remote-rcp work properly, and add others (ssh, http, ..?)

 - Make the compiler optimise its output

   now the lisp is mostly lexically scoped, there should be much
   more potential for aggressive optimisation


Manual tasks:
=============

 + Document the error-mode and interrupt-mode variables

 + Document the internals (i.e. the C interface)
