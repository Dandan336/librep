[ This is -*-Indented-Text-*- ]

TODO list for librep
********************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -


Outstanding bugs
================

 ! doesn't handle NaN or Inf in floats properly (at all)

 ! ((call/cc call/cc) (call/cc call/cc)) can't be interrupted, and it
   eats all memory

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! It's relatively easy to blow the stack when regexp matching. Try
   searching for `/\*(.|\n)*\*/' in a C file with reasonable large
   comments.

 ! If a compiled file FOO.jlc is made from source file FOO, but FOO is
   newer, load doesn't notice, and loads the invalid FOO.jlc

 ! it's impossible for scripts to present their own --help option

 ! non-fixnum numbers can't be dumped

 ! `random' only accepts its range as a fixnum


General programming tasks:
==========================

 - Define let and let* as macros (with named variants)?

   let can be done easily:

   (defmacro let args
     (let
	 (fun var values)
       (when (symbolp (car args))
	 ;; named let
	 (setq fun (car args))
	 (setq args (cdr args)))
       (setq vars (mapcar (lambda (x)
			    (if (consp x)
				(car x)
			      x)) (car args)))
       (setq values (mapcar (lambda (x)
			      (if (consp x)
				  (cons 'progn (cdr x))
				nil)) (car args)))
       (if fun
	   `(letrec ((,fun (lambda ,vars ,@(cdr args))))
	      (,fun ,@values))
	 `((lambda ,vars ,@(cdr args)) ,@values))))

   let* also has a simple expansion:

   (let* ((x 1) (y x)) (+ x y)) == ((lambda (x) ((lambda (y) (+ x y)) x)) 1)

   But the problem is that the compiler will generate worse code for
   this than the current approach (it doesn't notice that the embedded
   lambdas can use a single binding frame)

   (The other drawback to this approach is that interpreted code will
   run more slowly..)

 - do JIT compilation of bytecode where profitable

   there's now GNU lightning, a VCODE-like system, using C macros to do
   portable runtime code generation

   Only do this for _heavily_ used bytecode subrs. Measure this by
   adding an extra vector slot, and counting the number of vm
   iterations

 - allow modules to run with customized environments, but for the
   compiler to detect and handle this correctly

   basically, it needs to work out when primitives have been redefined,
   so as not to use the built-in compilers/transformations for them

   It would probably be easier to just add a module system (the
   scheme48 system looks good..)

 - Optimize compilation of case statements

   1. handle constant keys

   2. optimize the search

 - Eliminate lexically-bound symbols from compiled code?

   currently the symbols are only used when the binding is created; all
   access is done through lexical addressing.

   lexical leaf procedures (i.e. those without any `enclose' or
   `make-closure' instructions) don't need to include symbols, since
   there's no way they could be needed

 - Sandboxed bytecode interpreter

   the default vm assumes that the compiler makes no errors (i.e. it
   ignores some range/type checks)

   a `safe' vm would check for things like:

     * stack overflow
     * range of indices to the vector of constants
     * validity of refg/setg instructions
     * invalid lexical addresses to refn/setn
     * etc..

   implement this as a plugin?

 - Implement weak-pairs or equivalent

   could use normal cons types for this, but allocate from a `weak'
   freelist, then only gc has to differentiate between weak and
   non-weak pairs

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Add more backends for accessing remote files

   Make remote-rcp work properly, and add others (ssh, http, ..?)

 - Make the compiler optimise its output

   now the lisp is mostly lexically scoped, there should be much
   more potential for aggressive optimisation


Manual tasks:
=============

 + Document the error-mode and interrupt-mode variables

 + Document the internals (i.e. the C interface)
